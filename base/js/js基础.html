<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>js基础 | </title><meta name="description" content="">
    <link rel="modulepreload" href="/assets/app.4afcc58d.js"><link rel="modulepreload" href="/assets/js基础.html.81abd258.js"><link rel="modulepreload" href="/assets/js基础.html.d9c4f284.js"><link rel="prefetch" href="/assets/index.html.336290ef.js"><link rel="prefetch" href="/assets/css.html.506e1593.js"><link rel="prefetch" href="/assets/js.html.a0bf57de.js"><link rel="prefetch" href="/assets/vue.html.84befb48.js"><link rel="prefetch" href="/assets/docker.html.e8d84372.js"><link rel="prefetch" href="/assets/webpack.html.beed4981.js"><link rel="prefetch" href="/assets/index.html.424547b0.js"><link rel="prefetch" href="/assets/http.html.c64f9040.js"><link rel="prefetch" href="/assets/WebSocket.html.397bc3fc.js"><link rel="prefetch" href="/assets/浏览器.html.3be9ac20.js"><link rel="prefetch" href="/assets/设计模式.html.6cbb97f1.js"><link rel="prefetch" href="/assets/gungnir博客配置.html.39a6fc28.js"><link rel="prefetch" href="/assets/nuxt.html.ffd9bbf8.js"><link rel="prefetch" href="/assets/vue.html.16fcb2f8.js"><link rel="prefetch" href="/assets/css.html.ed27349b.js"><link rel="prefetch" href="/assets/html.html.5d591db3.js"><link rel="prefetch" href="/assets/ES6.html.d18c8b41.js"><link rel="prefetch" href="/assets/js文件处理.html.c503b127.js"><link rel="prefetch" href="/assets/ts.html.04aa003e.js"><link rel="prefetch" href="/assets/404.html.7d858b3d.js"><link rel="prefetch" href="/assets/index.html.de26035a.js"><link rel="prefetch" href="/assets/index.html.deae5fb3.js"><link rel="prefetch" href="/assets/index.html.4cb84524.js"><link rel="prefetch" href="/assets/css.html.93508d1c.js"><link rel="prefetch" href="/assets/js.html.fc6d541f.js"><link rel="prefetch" href="/assets/vue.html.3c6162b9.js"><link rel="prefetch" href="/assets/docker.html.bbb72b70.js"><link rel="prefetch" href="/assets/webpack.html.84c1a7de.js"><link rel="prefetch" href="/assets/index.html.3b7f3b90.js"><link rel="prefetch" href="/assets/http.html.9621d1aa.js"><link rel="prefetch" href="/assets/WebSocket.html.7c6ff825.js"><link rel="prefetch" href="/assets/浏览器.html.a2b666bb.js"><link rel="prefetch" href="/assets/设计模式.html.7377c483.js"><link rel="prefetch" href="/assets/gungnir博客配置.html.7938d25f.js"><link rel="prefetch" href="/assets/nuxt.html.6dd0db5d.js"><link rel="prefetch" href="/assets/vue.html.2ec71294.js"><link rel="prefetch" href="/assets/css.html.225aaa80.js"><link rel="prefetch" href="/assets/html.html.f56f005d.js"><link rel="prefetch" href="/assets/ES6.html.b981eacd.js"><link rel="prefetch" href="/assets/js文件处理.html.9a722572.js"><link rel="prefetch" href="/assets/ts.html.f117f106.js"><link rel="prefetch" href="/assets/404.html.55b7a351.js"><link rel="prefetch" href="/assets/index.html.5977f679.js"><link rel="prefetch" href="/assets/index.html.b927cf80.js"><link rel="prefetch" href="/assets/404.c52688da.js"><link rel="prefetch" href="/assets/HomePage.4b2e5824.js"><link rel="prefetch" href="/assets/Layout.8b63924c.js"><link rel="prefetch" href="/assets/Links.a9ebced6.js"><link rel="prefetch" href="/assets/Post.3484b530.js"><link rel="prefetch" href="/assets/Tags.61676cf8.js">
    <link rel="stylesheet" href="/assets/style.d9da5232.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar is-fixed is-visible invert"><span><a href="/" class=""><span class="site-name">BWLLzlx的个人博客</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--><!----><span>首页</span><!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="基础"><span class="title"><!----><span>基础</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="基础"><span class="title"><!----><span>基础</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/base/h5c3/html.md" class="" aria-label="h5c3"><!--[--><!--]--><!----><span>h5c3</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/base/js/js基础.md" class="" aria-label="js"><!--[--><!--]--><!----><span>js</span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Vue框架"><span class="title"><!----><span>Vue框架</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Vue框架"><span class="title"><!----><span>Vue框架</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/vue/vue.md" class="" aria-label="vue"><!--[--><!--]--><!----><span>vue</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/vue/nuxt.md" class="" aria-label="服务端渲染"><!--[--><!--]--><!----><span>服务端渲染</span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工程化"><span class="title"><!----><span>工程化</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工程化"><span class="title"><!----><span>工程化</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/engineer/docker.md" class="" aria-label="docker"><!--[--><!--]--><!----><span>docker</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/engineer/webpack.md" class="" aria-label="webpack"><!--[--><!--]--><!----><span>webpack</span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="知识体系完善"><span class="title"><!----><span>知识体系完善</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="知识体系完善"><span class="title"><!----><span>知识体系完善</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/pro/浏览器.md" class="" aria-label="浏览器"><!--[--><!--]--><!----><span>浏览器</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pro/http.md" class="" aria-label="http协议"><!--[--><!--]--><!----><span>http协议</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pro/WebSocket.md" class="" aria-label="WebSocket协议"><!--[--><!--]--><!----><span>WebSocket协议</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pro/设计模式.md" class="" aria-label="设计模式"><!--[--><!--]--><!----><span>设计模式</span><!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--><!----><span>首页</span><!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="基础"><span class="title"><!----><span>基础</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="基础"><span class="title"><!----><span>基础</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/base/h5c3/html.md" class="" aria-label="h5c3"><!--[--><!--]--><!----><span>h5c3</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/base/js/js基础.md" class="" aria-label="js"><!--[--><!--]--><!----><span>js</span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Vue框架"><span class="title"><!----><span>Vue框架</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Vue框架"><span class="title"><!----><span>Vue框架</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/vue/vue.md" class="" aria-label="vue"><!--[--><!--]--><!----><span>vue</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/vue/nuxt.md" class="" aria-label="服务端渲染"><!--[--><!--]--><!----><span>服务端渲染</span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工程化"><span class="title"><!----><span>工程化</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工程化"><span class="title"><!----><span>工程化</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/engineer/docker.md" class="" aria-label="docker"><!--[--><!--]--><!----><span>docker</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/engineer/webpack.md" class="" aria-label="webpack"><!--[--><!--]--><!----><span>webpack</span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="知识体系完善"><span class="title"><!----><span>知识体系完善</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="知识体系完善"><span class="title"><!----><span>知识体系完善</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/pro/浏览器.md" class="" aria-label="浏览器"><!--[--><!--]--><!----><span>浏览器</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pro/http.md" class="" aria-label="http协议"><!--[--><!--]--><!----><span>http协议</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pro/WebSocket.md" class="" aria-label="WebSocket协议"><!--[--><!--]--><!----><span>WebSocket协议</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pro/设计模式.md" class="" aria-label="设计模式"><!--[--><!--]--><!----><span>设计模式</span><!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">js <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="js基础"><!--[--><!--]--><!----><span>js基础</span><!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#json数据格式" class="router-link-active router-link-exact-active sidebar-item" aria-label="JSON数据格式"><!--[--><!--]--><!----><span>JSON数据格式</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#数据类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="数据类型"><!--[--><!--]--><!----><span>数据类型</span><!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#数据类型分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="数据类型分类"><!--[--><!--]--><!----><span>数据类型分类</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#数据类型转换" class="router-link-active router-link-exact-active sidebar-item" aria-label="数据类型转换"><!--[--><!--]--><!----><span>数据类型转换</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#数据类型判断" class="router-link-active router-link-exact-active sidebar-item" aria-label="数据类型判断"><!--[--><!--]--><!----><span>数据类型判断</span><!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#js执行机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="JS执行机制"><!--[--><!--]--><!----><span>JS执行机制</span><!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#预解析" class="router-link-active router-link-exact-active sidebar-item" aria-label="预解析"><!--[--><!--]--><!----><span>预解析</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#代码执行" class="router-link-active router-link-exact-active sidebar-item" aria-label="代码执行"><!--[--><!--]--><!----><span>代码执行</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#垃圾回收" class="router-link-active router-link-exact-active sidebar-item" aria-label="垃圾回收"><!--[--><!--]--><!----><span>垃圾回收</span><!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="函数"><!--[--><!--]--><!----><span>函数</span><!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#定义函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="定义函数"><!--[--><!--]--><!----><span>定义函数</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#调用函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="调用函数"><!--[--><!--]--><!----><span>调用函数</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#回调函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="回调函数"><!--[--><!--]--><!----><span>回调函数</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#立即执行函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="立即执行函数"><!--[--><!--]--><!----><span>立即执行函数</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#原型" class="router-link-active router-link-exact-active sidebar-item" aria-label="原型"><!--[--><!--]--><!----><span>原型</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#执行上下文" class="router-link-active router-link-exact-active sidebar-item" aria-label="执行上下文"><!--[--><!--]--><!----><span>执行上下文</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#闭包" class="router-link-active router-link-exact-active sidebar-item" aria-label="闭包"><!--[--><!--]--><!----><span>闭包</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#作用域和作用域链" class="router-link-active router-link-exact-active sidebar-item" aria-label="作用域和作用域链"><!--[--><!--]--><!----><span>作用域和作用域链</span><!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="对象"><!--[--><!--]--><!----><span>对象</span><!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#对象创建模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="对象创建模式"><!--[--><!--]--><!----><span>对象创建模式</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#继承模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="继承模式"><!--[--><!--]--><!----><span>继承模式</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#this对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="this对象"><!--[--><!--]--><!----><span>this对象</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#常用内置对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="常用内置对象"><!--[--><!--]--><!----><span>常用内置对象</span><!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#dom-api" class="router-link-active router-link-exact-active sidebar-item" aria-label="DOM API"><!--[--><!--]--><!----><span>DOM API</span><!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#dom操作步骤" class="router-link-active router-link-exact-active sidebar-item" aria-label="DOM操作步骤"><!--[--><!--]--><!----><span>DOM操作步骤</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#事件注册" class="router-link-active router-link-exact-active sidebar-item" aria-label="事件注册"><!--[--><!--]--><!----><span>事件注册</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#事件解绑" class="router-link-active router-link-exact-active sidebar-item" aria-label="事件解绑"><!--[--><!--]--><!----><span>事件解绑</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#事件流-捕获-冒泡" class="router-link-active router-link-exact-active sidebar-item" aria-label="事件流（捕获/冒泡）"><!--[--><!--]--><!----><span>事件流（捕获/冒泡）</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#事件对象event" class="router-link-active router-link-exact-active sidebar-item" aria-label="事件对象event"><!--[--><!--]--><!----><span>事件对象event</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#事件委托" class="router-link-active router-link-exact-active sidebar-item" aria-label="事件委托"><!--[--><!--]--><!----><span>事件委托</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#鼠标事件" class="router-link-active router-link-exact-active sidebar-item" aria-label="鼠标事件"><!--[--><!--]--><!----><span>鼠标事件</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#键盘事件" class="router-link-active router-link-exact-active sidebar-item" aria-label="键盘事件"><!--[--><!--]--><!----><span>键盘事件</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#获取和设置元素大小和位置" class="router-link-active router-link-exact-active sidebar-item" aria-label="获取和设置元素大小和位置"><!--[--><!--]--><!----><span>获取和设置元素大小和位置</span><!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#bom-api" class="router-link-active router-link-exact-active sidebar-item" aria-label="BOM API"><!--[--><!--]--><!----><span>BOM API</span><!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#window对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="window对象"><!--[--><!--]--><!----><span>window对象</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#window对象的事件" class="router-link-active router-link-exact-active sidebar-item" aria-label="window对象的事件"><!--[--><!--]--><!----><span>window对象的事件</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#location对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="location对象"><!--[--><!--]--><!----><span>location对象</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#navigator对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="navigator对象"><!--[--><!--]--><!----><span>navigator对象</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#history对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="history对象"><!--[--><!--]--><!----><span>history对象</span><!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#ajax" class="router-link-active router-link-exact-active sidebar-item" aria-label="AJAX"><!--[--><!--]--><!----><span>AJAX</span><!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#关于xml" class="router-link-active router-link-exact-active sidebar-item" aria-label="关于XML"><!--[--><!--]--><!----><span>关于XML</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#ajax的特点" class="router-link-active router-link-exact-active sidebar-item" aria-label="AJAX的特点"><!--[--><!--]--><!----><span>AJAX的特点</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#关于http协议" class="router-link-active router-link-exact-active sidebar-item" aria-label="关于HTTP协议"><!--[--><!--]--><!----><span>关于HTTP协议</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#关于node-js与express框架" class="router-link-active router-link-exact-active sidebar-item" aria-label="关于Node.js与Express框架"><!--[--><!--]--><!----><span>关于Node.js与Express框架</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#原生ajax发送请求" class="router-link-active router-link-exact-active sidebar-item" aria-label="原生AJAX发送请求"><!--[--><!--]--><!----><span>原生AJAX发送请求</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#axios发送ajax请求" class="router-link-active router-link-exact-active sidebar-item" aria-label="axios发送AJAX请求"><!--[--><!--]--><!----><span>axios发送AJAX请求</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#fetch-发送ajax请求" class="router-link-active router-link-exact-active sidebar-item" aria-label="fetch（）发送AJAX请求"><!--[--><!--]--><!----><span>fetch（）发送AJAX请求</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/base/js/js%E5%9F%BA%E7%A1%80.html#跨域与解决" class="router-link-active router-link-exact-active sidebar-item" aria-label="跨域与解决"><!--[--><!--]--><!----><span>跨域与解决</span><!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="/base/js/ES6.html" class="sidebar-item" aria-label="ES6"><!--[--><!--]--><!----><span>ES6</span><!--[--><!--]--></a><!----></li><li><a href="/base/js/js%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86.html" class="sidebar-item" aria-label="js文件处理"><!--[--><!--]--><!----><span>js文件处理</span><!--[--><!--]--></a><!----></li><li><a href="/base/js/ts.html" class="sidebar-item" aria-label="ts"><!--[--><!--]--><!----><span>ts</span><!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><div class="page-content"><!--[--><main class="page"><!--[--><div class="article-header" style=""><!----><div class="article-header-content"><!----><h1 class="article-title">js基础</h1><!----><div class="article-icons"><div class="article-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M313.6 304c-28.7 0-42.5 16-89.6 16-47.1 0-60.8-16-89.6-16C60.2 304 0 364.2 0 438.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-25.6c0-74.2-60.2-134.4-134.4-134.4zM400 464H48v-25.6c0-47.6 38.8-86.4 86.4-86.4 14.6 0 38.3 16 89.6 16 51.7 0 74.9-16 89.6-16 47.6 0 86.4 38.8 86.4 86.4V464zM224 288c79.5 0 144-64.5 144-144S303.5 0 224 0 80 64.5 80 144s64.5 144 144 144zm0-240c52.9 0 96 43.1 96 96s-43.1 96-96 96-96-43.1-96-96 43.1-96 96-96z"/></svg><span>BWLLzlx</span></div><!----><div class="article-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M17.618 5.968l1.453-1.453 1.414 1.414-1.453 1.453a9 9 0 11-1.414-1.414zM12 20a7 7 0 100-14 7 7 0 000 14zM11 8h2v6h-2V8zM8 1h8v2H8V1z"/></svg><span>44 min</span></div></div></div><!----></div><!--[--><!--]--><!--]--><div class="theme-gungnir-content"><!--[--><!--]--><div><p>JS是运行在<strong>客户端的脚本语言</strong>，不需要编译，是<strong>解释型</strong>语言</p><p>浏览器分成两部分，渲染引擎（内核）和JS引擎（JS解释器）</p><p>JS的组成部分：JS语法、DOM、BOM</p><p>JS的书写位置：行内（如onclick）、内嵌（写到script中）、外部（script src=js）</p><p>JS语句后面可以加分号也可以不加。<strong>特殊情况</strong>：（）和【】，最好都在前面加分号，避免和上面的语句被错误连接在一起</p><h2 id="json数据格式" tabindex="-1"><a class="header-anchor" href="#json数据格式" aria-hidden="true">#</a> JSON数据格式</h2><p>存储方式：<strong>键值对</strong></p><p>格式：{“key”：“value”，[“key”：“value”，……] }，不能识别换行等，需要转义，包括\r,\n,\,\&quot;等</p><p>值：字符串、数字、json对象、数组、null</p><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h2><p>变量是内存中、用于存放数据的、空间。变量的声明：var，区分大小写。JS是<strong>弱类型</strong>语言，变量的类型会在运行过程中自动确定。</p><p>”<strong>typeof</strong> 变量“可以得到数据类型</p><h3 id="数据类型分类" tabindex="-1"><a class="header-anchor" href="#数据类型分类" aria-hidden="true">#</a> 数据类型分类</h3><h5 id="基本类型-值类型" tabindex="-1"><a class="header-anchor" href="#基本类型-值类型" aria-hidden="true">#</a> 基本类型（值类型）</h5><p>基本类型的变量存放在<strong>栈</strong>内存，较小。基本类型是<strong>传值</strong>的，两个基本类型的变量a和b，b=a创建一个新的对象b，b里面存储的是a的数据本身</p><ul><li>String：默认“”。常用转义符：斜杠n、俩斜杠、斜杠&#39;、斜杠“、斜杠t（缩进）、斜杠b（空格）</li><li>Number：默认0。8进制0开头、16进制0x开头。特殊值：Number.MAX_VALUE、Infinity、NaN</li><li>Boolean：默认false。参与加法当1和0</li><li>Null：默认null。表示变量存的东西是空，<strong>赋值了</strong>，typeof值为null的变量，可以发现是object类型，表示空对象，要放东西但是还没放。使用null的场景：初始赋值为null，赋值为对象；结束时赋值为null，切断引用，让变量指向的对象变成垃圾对象（没有引用指向它就是垃圾对象），被垃圾回收器回收</li><li>Undefined：默认undefined。声明变量<strong>没赋值</strong>是Undefined类型。没赋值不知道是什么类型，所以就给个特殊类型Undefined，值是undefined</li></ul><h5 id="引用类型" tabindex="-1"><a class="header-anchor" href="#引用类型" aria-hidden="true">#</a> 引用类型</h5><p>引用类型是多个值构成的变量，有属性和方法。引用类型的变量存放在<strong>堆内存</strong>中，较大，而引用类型的<strong>变量的地址</strong>存放在栈内存的变量中。不能直接访问堆内存里面的内容，通过栈内存中的地址才能访问堆内存中的变量。也就是说<strong>引用类型是传址</strong>的，例如两个数组a和b，b = a创建一个引用b，把栈内存中a的堆内存地址给b。这时候如果a.push(1)，数组a和b还是存放同一个堆内存的地址。但如果是a = 【1，2】，就是在堆中新开辟一块空间存放[1,2]然后a的值改为那块新地址。如果a=null就是给a赋值成null，a是有值的，而这时候【1，2】就成了垃圾对象（没有引用指向它就是垃圾对象），GC就会把a指向的空间回收了，但是a本身没有回收。</p><ul><li><p>对象Object：</p><ul><li><p>创建对象：</p><ul><li>Object构造函数：var obj = new Object()，再一个一个属性添加obj.key = value。缺点是语句较多</li><li>对象字面量{}：var obj = {键值对}。解决了第一种的缺点，不用一条一条属性写，缺点是如多个对象就重复</li><li>工厂模式：创建函数用参数获取值，函数内部var一个对象，用获取的值给对象赋值，返回对象。缺点：解决了第二种的缺点，问题是都是Object类型</li><li>使用构造函数：先创建构造函数，然后用new和构造函数创建对象。解决了第三个的缺点，不再是Object类型而是自定义的类型（用instanceof可以判断出来这个具体的类型是什么）。注意<strong>方法用原型</strong>。同类型的实例对象之间属性是不同的，必须在每个对象内部设置。但是方法是相同的，如果每个对象内都设置就是<strong>浪费内存</strong>，而每个实例对象都有隐式原型，和构造函数的显式原型相同，也就是说所有实例对象的__proto__都是相同的，所以直接给构造函数的显示原型添加方法即可，节省了内存。当实例调用方法时，先在自己的对象内部找，找不到就顺着隐式原型链往上找</li></ul></li><li><p>使用对象：obj.key、obj[&#39;key&#39;]、obj.fun（）、for（k in obj）输出k得到obj每个key，则obj[k]就是obj[&#39;key&#39;]就是value</p><p>只能用obj[&#39;key&#39;]的情况：</p><ul><li>属性名有<strong>特殊字符</strong>，那么.xxx-xxx或者含有空格的就不行</li><li><strong>属性名是变量</strong>，例如var attr = &#39;age&#39; ，想添加age属性，obj.attr = 18，那就不行，但是可以obj[attr] = 18</li></ul></li></ul></li><li><p>数组Array：</p><ul><li>创建数组： <ul><li>var a = new Array（）</li><li>var a = []</li></ul></li></ul></li><li><p>函数Function：先声明后调用。每个函数都有<strong>arguments伪数组</strong>：每个函数都有一个args伪数组，存储实参</p><ul><li><p>声明函数：</p><ul><li>function name（）{}</li><li>匿名函数（name是变量的名字）var name = function（）{}</li><li>立即执行函数（function（）{}）（），不需要调用，可以看作是后面的（）调用了上面的函数，可以传参。作用是创建独立的作用域，不会命名冲突</li></ul></li><li><p>调用函数：四种调用方式，差别在于this的初始化：</p><ul><li>全局函数调用</li><li>对象方法调用</li><li>构造器new调用</li><li>上下文调用call、apply、bind</li></ul></li></ul></li></ul><h3 id="数据类型转换" tabindex="-1"><a class="header-anchor" href="#数据类型转换" aria-hidden="true">#</a> 数据类型转换</h3><p>转为String：toString、String（）、隐式转换：利用相加特性，字符串和其他类型拼接（+）得到字符串，</p><p>转为Number：parseInt（）获取整数（会向下取整、去除单位、如果开头不是数字会NaN）、parseFloat（）、Number（）、减乘除</p><p>转为Boolean：Boolean（）：表示空、否定（包括‘’、null、0、NaN、undefined）会变成false、其余变成true</p><h3 id="数据类型判断" tabindex="-1"><a class="header-anchor" href="#数据类型判断" aria-hidden="true">#</a> 数据类型判断</h3><ul><li>typeof，返回<strong>字符串表达</strong>，例如‘number’这个字符串、‘undefined’这个字符串和undefined还是不一样的，typeof null是‘object’，所以<strong>判断不出来null</strong>，而且也判断不出来array，数组也是判断成&#39;object&#39;，<strong>但是function可以</strong></li><li>instanceof，直译左边是不是右边的实例，判断<strong>对象</strong>的具体类型，<strong>返回true和false</strong>，函数和数组都是对象</li><li>===（全等），可以用来判断null和undefined，因为他们<strong>只有这一个值</strong>，如果是这个值就说明是这个类型</li><li>（补充）constructor，指向构造函数，可判断对象的类型</li></ul><h2 id="js执行机制" tabindex="-1"><a class="header-anchor" href="#js执行机制" aria-hidden="true">#</a> JS执行机制</h2><p>JS解析器（JS引擎）在运行JS代码时分成两步：预解析、代码执行。</p><h3 id="预解析" tabindex="-1"><a class="header-anchor" href="#预解析" aria-hidden="true">#</a> 预解析</h3><p>JS引擎把所有var和function<strong>提升</strong>到<strong>当前</strong>作用域的最前面。<strong>先变量提升，再函数提升</strong></p><ul><li>变量预解析（变量提升）：提升<strong>声明</strong>操作到<strong>当前</strong>作用域最前面，赋值是没有的 <ul><li>如果是var fun = function（）{}，它只是把var fun这个变量声明提升，后面的赋值是没有提升的，所以如果顺序写的不对，先fun（）再var fun = function（）{}的话，经过预解析就是先var fun，然后fun（），然后var fun = function（）{}，就会报错</li><li>如果是基本类型的变量，没了赋值只不过是会undefined而已</li></ul></li><li>函数预解析（函数提升）：提升<strong>声明</strong>操作到<strong>当前</strong>作用域最前面，调用是没有的 <ul><li>如果是function fun（）{}，虽然函数调用不会提升，但是这句全部都属于函数声明，也就是说函数已经写好了，调用是没问题的</li></ul></li></ul><h3 id="代码执行" tabindex="-1"><a class="header-anchor" href="#代码执行" aria-hidden="true">#</a> 代码执行</h3><p>JS是<strong>单线程</strong>，H5提出标准允许多线程，出现了同步（按排列顺序执行程序）和异步（做事件a的同时可以做事件b）。同步任务放在<strong>执行栈</strong>，异步任务也就是回调函数（事件、加载、定时器）放到<strong>任务队列</strong>。先执行执行栈的同步任务，异步任务交给异步进程处理（可以处理ajax、事件、计时器），等着你触发事件、计时器、ajax，当<strong>触发后放把异步任务到任务队列</strong>先不执行，等执行栈的所有同步任务执行完毕，读取任务队列的异步任务放到执行栈执行。例如一个按钮绑定一个点击事件，执行栈没东西，异步进程处理好了这个点击事件，当点击按钮后执行队列中加入点击事件调用的任务然后执行。不断点击，执行栈不断获取任务、执行任务，称为<strong>事件循环</strong></p><h3 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h3><p>自动释放不是回收，回收会先等一会（等回收机制GC的下一次运行），释放是马上做掉</p><ul><li>函数中的局部变量（栈）：会在函数结束时自动释放</li><li>对象的释放（堆）：只要是对象，都需要先赋值null让原本对象指向的堆内存的对象变成垃圾对象（<strong>没有被引用的对象就是垃圾对象</strong>），然后再回收堆内存的垃圾对象</li></ul><h2 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h2><p>函数是可以执行的对象，其他类型都不行</p><h3 id="定义函数" tabindex="-1"><a class="header-anchor" href="#定义函数" aria-hidden="true">#</a> 定义函数</h3><ul><li>函数声明：function name（）{}</li><li>表达式生成匿名函数：var name = function（）{}</li></ul><h3 id="调用函数" tabindex="-1"><a class="header-anchor" href="#调用函数" aria-hidden="true">#</a> 调用函数</h3><p>函数对象不用写括号，<strong>调用的时候写括号</strong></p><p>函数本质上都是需要对象来调用的。<strong>没写就是window</strong></p><ul><li><p>全局函数调用：函数作为一个<strong>全局函数</strong>调用。this指向window</p></li><li><p>对象方法调用：函数作为一个<strong>对象</strong>的方法来调用。this指向调用方法的对象</p></li><li><p>使用构造器调用：使用<strong>new调用构造函数</strong>创建新对象。this指向新构造的对象。在对象类型Object的通过new创建里面也有讲，<strong>new实际做的操作</strong>：创建一个新的空的对象，然后this指向新对象，对象调用构造函数进行赋值，然后<strong>自动返回this指向的对象</strong>，如果手动return基本类型，返回值类型不会被改，如果是引用类型就会被改。</p></li><li><p>上下文调用：<strong>临时让某个函数成为obj的方法</strong>，即使对象原本没有这个函数，也能被对象调用。每个函数对象都有call（）和apply（）方法，用函数调用call（）和apply（）会自动执行调用call/apply方法的函数，而且可以<strong>强制改变this指示的对象为call/apply参数</strong>。apply（）和call（）的区别：apply传递的参数只接受数组形式，call可以接受多个参数。this的值：</p><ul><li>如果传递对象和参数，this指向传递的对象</li><li>如果传递null和undefined指向window</li></ul></li><li><p>绑定事件调用：this指向<strong>绑定</strong>事件的dom对象</p></li></ul><h3 id="回调函数" tabindex="-1"><a class="header-anchor" href="#回调函数" aria-hidden="true">#</a> 回调函数</h3><ul><li>理解：定义了的、没调用的、最终会执行的</li><li>常见：dom事件回调函数、定时器回调函数、ajax回调函数、生命周期回调函数</li></ul><h3 id="立即执行函数" tabindex="-1"><a class="header-anchor" href="#立即执行函数" aria-hidden="true">#</a> 立即执行函数</h3><p>格式为（function（）{}）（）。<strong>不需要调用</strong>，可以看作是后面的（）调用了上面的函数，可以传参。下面的括号的参数是实参（全局作用域），上面的函数中的是形参（局部作用域）</p><p>作用是<strong>创建独立的作用域</strong>，不会命名冲突</p><p>可以通过window.xxx等于一个对象，<strong>向外暴露</strong>的这个对象，属性包括这个独立作用域内部的函数，这样就能通过window调用这个全局函数获取到这个对象，调用这个对象的方法也就是内部函数，这也是闭包的使用场景。</p><h3 id="原型" tabindex="-1"><a class="header-anchor" href="#原型" aria-hidden="true">#</a> 原型</h3><p>每个<strong>函数</strong>都有一个prototype属性，默认指向一个Object空<strong>对象</strong>也就是原型对象（<strong>除了Object构造函数</strong>，Object函数的prototype是个比较特殊的实例对象，它的__proto__属性是null）。原型对象有constructor属性指向函数</p><p>每个函数都有__proto__属性，是因为<strong>每个实例对象都有__proto__属性</strong>，而所有函数（包括Function构造函数自己也是）都是Function构造函数的实例对象。__proto__属性的值和Function构造函数的prototype一致，也就是说<strong>实例的隐式原型等于构造函数的显示原型</strong></p><p><strong>实例对象都能使用原型对象中的属性和方法</strong>。创建实例化对象的时候，会给当前对象添加__proto__属性，值取构造函数的prototype，能够通过__proto__属性找到prototype对象使用对象的方法，this.__proto__ = Fn.prototype</p><ul><li><p>显示原型和隐式原型</p><ul><li><p>显示原型：每个函数对象的prototype属性，在函数定义的时候生成</p></li><li><p>隐式原型：每个实例对象的__proto__属性，在创建对象的时候生成。用new创建对象实例的内部语句是this.__proto__ = Fn.prototype，所以每个实例对象都有__proto__属性而且和构造函数的prototype一样也就是<strong>指向同一个原型对象</strong>，这也是为什么每个实例对象都能使用原型对象的属性和方法。</p></li></ul></li><li><p>原型链</p><ul><li>原型链是<strong>隐式原型链</strong></li><li>读取会找原型链</li><li><strong>设置只会找当前对象，不会找原型链</strong>，如果没有就给当前对象添加属性</li><li><strong>方法通常定义在原型，属性通过构造函数定义在对象</strong></li></ul></li><li><p>理解显式原型和原型链的例子</p><ul><li>有函数Fn，Fn.prototype.fun = function(){}给函数Fn的原型对象添加方法fun，然后 var f = new Fn()创建Fn的实例f，自动执行this.__proto__ = Fn.prototype，让f对象的__proto__也指向了Fn的原型对象。这时候如果f.fun()，会<strong>先找f对象实例本身</strong>是否有fun（），没有的话就会<strong>找隐式原型</strong>__proto__指向的对象。如果Fn构造函数的原型本身也没有fun（），就要继续通过隐式原型找。因为Fn的原型对象是Object空对象，是Object构造函数的一个实例，可以通过它的__proto__属性来找（地址和Object构造函数的prototype相同），找到的就是原型链的尽头，不是Object，是个特殊的实例，<strong>__proto__属性是null</strong>，没法继续找了，所以如果找到尽头还是找不到就会返回undefined</li></ul></li><li><p>instanceof的使用。instanceof前面是实例，后面是函数。<strong>实例可以找多次隐式原型</strong>，函数只能找一次显式原型</p><ul><li>Function instanceof Function <ul><li>Function作为函数找显式原型，Function.prototype</li><li>Function作为实例找隐式原型，即构造函数的显式原型，构造函数是Function，所以是Function.prototype</li><li>true</li></ul></li><li>Function instanceof Object <ul><li>Object作为函数找显式原型，Object.prototype</li><li>Function作为实例找隐式原型，找构造函数的显式原型，构造函数是Function，所以是Function.prototype</li><li>不相等，Function.prototype实例找隐式原型，即构造函数的显式原型，Function.prototype是空对象，找空对象的隐式原型就是构造函数的显示原型，构造函数是Object，所以是Object.prototype</li><li>true</li></ul></li><li>Object instanceof Function <ul><li>Function作为函数找显式原型，Function.prototype</li><li>Object作为实例找隐式原型即构造函数的显式原型，Object作为实例是函数，构造函数是Function，所以是Function.prototype</li><li>true</li></ul></li><li>Object instanceof Object <ul><li>Object作为函数找显示原型，Object.prototype</li><li>Object作为实例找隐式原型即构造函数的显示原型，构造函数是Function，所以是Function.prototype</li><li>不相等，Function.prototype实例找隐式原型即构造函数的显式原型，构造函数是Object，所以是Object.prototype</li><li>true</li></ul></li></ul></li><li><p>题目常考特性</p><ul><li><p>函数的prototype对象变化时，会开辟新的堆内存存放新的对象，旧对象的隐式原型指向旧地址，新对象的隐式原型指向新地址</p></li><li><p>关系</p><p>函数的prototype属性指向显式原型，显式原型的constructor属性指向函数</p><p>所有对象都有__proto__属性，即隐式原型，等于构造函数的显式原型</p><p>内容</p><ul><li>Object实例obj1、function Object（）、Object.prototype</li><li>Function实例fun1（）、function Function（）、Function.prototype</li><li>fun1（）实例f1、function fun1（）、fun1.prototype</li></ul><p>特殊关系</p><ul><li>所有函数都是function Function（）的实例，所以所有函数的隐式原型等于构造函数Function（）的显式原型Function.prototype</li><li>除了Object对象以外，函数的prototype属性默认指向一个空对象，prototype对象是Object的实例，它的隐式原型等于构造函数Object（）的显示原型Object.prototype</li><li>Object对象的prototype指向一个特殊的对象，隐式原型为null</li><li>fun1（）的实例f1中，f1的__proto__指向构造函数的显式原型fun1.prototype，所以f1能访问fun1.prototype对象的属性。fun1.prototype是个空对象，也就是Object（）的实例，该实例的__proto__指向构造函数的显式原型Object.prototype，所以f1能访问Object.prototype对象的属性</li><li>将fun1看作实例对象，fun1的__proto__指向构造函数的显式原型Function.prototype，所以fun1能访问Function.prototype对象的属性。Function.prototype是空对象，也就是Object的实例，该实例的__proto__指向构造函数的显式原型Object.prototype，所以fun1能访问Object.prototype对象的属性</li></ul></li></ul></li></ul><h3 id="执行上下文" tabindex="-1"><a class="header-anchor" href="#执行上下文" aria-hidden="true">#</a> 执行上下文</h3><ul><li>变量提升与函数提升。<strong>先执行变量提升，再执行函数提升</strong>，变量提升和函数提升是执行上下文的结果</li><li>执行上下文 <ul><li>全局执行上下文 <ul><li><strong>执行</strong>全局代码前，将window<strong>确定</strong>为全局执行上下文</li><li>预处理（var 定义的变量 = undefined，function定义的函数 = function（）{}，并添加为window的属性和方法，然后this指向window）</li><li>执行全局代码</li></ul></li><li>函数执行上下文 <ul><li>函数<strong>执行</strong>前，不执行的时候都不创建，<strong>创建</strong>对应函数的执行上下文对象，局部对象存在栈中</li><li>预处理（形参变量赋值为实参，arguments赋值实参列表，剩下和全局一样）</li><li>执行</li></ul></li></ul></li><li>执行上下文栈 <ul><li>在全局代码<strong>执行前</strong>创建一个执行上下文栈，<strong>window确定后</strong>将window压栈，创建函数执行上下文后压栈，函数执行完就出栈，最后栈剩下window</li></ul></li></ul><h3 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h3><ul><li><p>闭包的产生</p><ul><li>函数a中<strong>嵌套</strong>函数b，在b中<strong>引用</strong>了a定义的变量，<strong>调用</strong>了外部函数a（如果不调用执行外部函数，内部的函数就没法定义）或者内部函数定义（用function 函数名 = {}的方式才可以，因为有函数提升），就产生了闭包。每调用一次外部函数就产生一次闭包</li></ul></li><li><p>闭包的理解方式</p><ul><li>内部嵌套的函数就叫闭包</li><li>闭包是个对象，包含<strong>a定义了的并且被引用的变量</strong>，在b的内部</li></ul></li><li><p>闭包的使用引出闭包的作用</p><ul><li>将<strong>内部函数作为外部函数a的返回值</strong>，<strong>创建变量 = 外部函数a（）</strong>，这个变量得到的就是内部函数（变量指向内部函数），内部函数调用了的外部函数的参数会保留下来</li><li>将函数<strong>作为参数</strong>传递给另一个函数，例如function outer = { setTimeOut（function（）{}， time）}就是外部函数outer中调用setTImeOut（），把匿名函数作为参数给setTImeOut（）</li></ul></li><li><p>闭包的作用</p><ul><li><p>局部变量存放在栈当中，函数执行完之后局部变量会被立即释放，<strong>闭包使得这个变量活下来了</strong></p><p>当外部函数的返回值是内部函数时，并且在全局作用域声明一个变量 = 外部函数，就相当于有个引用指向这个内部函数对象，外部函数执行完之后这个内部函数（指的是堆内存中的变量不是栈内存里的存地址的变量）<strong>因为不是垃圾对象，所以这个内部函数对象没有被删除</strong>（指向它的栈内存变量倒是被删了），而这个内部函数就是有闭包，也就是说在内部函数中的变量都活下来了</p></li><li><p>让外部函数a中的<strong>变量可以被全局作用域操作</strong>（<strong>不能直接操作a里面的变量</strong>毕竟是局部作用域，要操作只能靠闭包也就是内部函数b）</p></li></ul></li><li><p>闭包的生命周期，那就是内部函数的生命周期</p><ul><li>创建：在调用<strong>执行外部函数的时候，创建了局部上下文对象并且预处理的时候做了函数提升</strong>，这时候内部函数就创建了</li><li>死亡：内部函数成为垃圾对象的时候死亡，也就是没有引用指向它了</li></ul></li><li><p>闭包的使用：自定义JS模块</p><ul><li><strong>向函数外暴露内部函数b</strong>（也就是函数a返回内部函数b）使得在全局作用域能够操作外部函数a的变量。如果要暴露多个函数就返回一个对象，对象的属性是内部函数</li><li>立即执行函数添加内部函数，给window设置属性 = 对象xxx，对象xxx的属性包括内部函数，这样在外部能（window.xxx.内部函数）进行调用，和上面的区别是，不需要return也就是不需要调用外部函数并且找一个变量指向它</li></ul></li><li><p>闭包的缺点</p><ul><li>执行完之后函数内的局部变量<strong>没有释放</strong>，造成<strong>内存泄漏</strong>（泄露就是变少的意思，内存泄漏就是内存慢慢变少，会慢慢变少就是因为不知不觉越占越多，就是因为没有及时释放掉占用的内存），内存泄露后容易造成内存溢出（供不应求）。内存泄漏常见原因：函数内部生成隐式全局变量，回调函数或者计时器没有被清理，闭包</li></ul></li></ul><h3 id="作用域和作用域链" tabindex="-1"><a class="header-anchor" href="#作用域和作用域链" aria-hidden="true">#</a> 作用域和作用域链</h3><p>作用域是指变量的有效范围。es6之前分为全局作用域（script内部或者js文件）和局部作用域（函数作用域）。<strong>ES6之前没有块级作用域</strong>（在if的{}中或者for的{}中的作用域，例如在if的{}里面声明了变量a，在外面是不能用的。但是es6之前没有块级作用域，这个就相当于在它的执行上下文对象中。在函数内部没有声明直接使用的变量属于全局变量，是<strong>隐式全局变量</strong>。隐式全局变量不会被全局提升，也不会在函数内部被提升，需要当函数调用之后，才能创建出这个变量。</p><p>作用域链：内部函数能访问外部函数的变量，<strong>从里到外</strong>链式查找变量的值，就近原则</p><h2 id="对象" tabindex="-1"><a class="header-anchor" href="#对象" aria-hidden="true">#</a> 对象</h2><p>对象是数据的封装，方便操作数据。操作对象的属性：对象[&#39;属性名&#39;]、对象.属性名</p><h3 id="对象创建模式" tabindex="-1"><a class="header-anchor" href="#对象创建模式" aria-hidden="true">#</a> 对象创建模式</h3><ul><li>Object构造函数：var obj = new Object()，再一个一个属性添加obj.key = value。缺点是语句较多</li><li>对象字面量{}：var obj = {键值对}。解决了第一种的缺点，不用一条一条属性写，缺点是如多个对象就重复</li><li>工厂模式：创建函数用参数获取值，函数内部var一个对象，用获取的值给对象赋值，返回对象。缺点：解决了第二种的缺点，问题是都是Object类型</li><li>使用构造函数：先创建构造函数，然后用new和构造函数创建对象。解决了第三个的缺点，不再是Object类型而是自定义的类型（用instanceof可以判断出来这个具体的类型是什么）。注意<strong>方法用原型</strong>。同类型的实例对象之间属性是不同的，必须在每个对象内部设置。但是方法是相同的，如果每个对象内都设置就是<strong>浪费内存</strong>，而每个实例对象都有隐式原型，和构造函数的显式原型相同，也就是说所有实例对象的__proto__都是相同的，所以直接给构造函数的显示原型添加方法即可，节省了内存。当实例调用方法时，先在自己的对象内部找，找不到就顺着隐式原型链往上找</li></ul><h3 id="继承模式" tabindex="-1"><a class="header-anchor" href="#继承模式" aria-hidden="true">#</a> 继承模式</h3><ul><li><p>原型链继承</p><p>除了Object类型的构造函数的显式原型<strong>默认是一个空的Object对象</strong>，相当于这么一句：XXX.prototype = {}。XXX的实例就能通过隐式原型XXX链找到这个空对象，空对象没有的话就找这个空对象的隐式原型也就是Object的显式原型，就可以用Object原型对象里面的方法例如toString（）</p><p>如果想让实例能用toString可以靠XXX.prototype = {}，那如果<strong>想让实例用别的类的方法</strong>只需要XXX.prototype = new YYY（）</p><p>XXX的实例xxx.constructor，找constructor也是找隐式原型链，直到找到那个空对象才有constructor属性，而这个constructor指向的是（谁用prototype找到他的），<strong>结果发现找到的是YYY</strong>。所以XXX.prototype = new YYY之后，还要<strong>加上XXX.prototype.constructor = XXX</strong>，这样之后找constructor的时候就能在XXX.prototype里面找到，而不用再去找【（XXX.prototype也就是YYY实例）的隐式原型】</p></li><li><p>通过构造函数继承</p><p>在子类型的构造函数中，通过call（）调用父类型的构造函数，让this对象<strong>临时使用父类型的构造函数获取属性</strong>，Father.call（this，参数），相当于调用this.Father（参数）实现：this.属性 = 参数</p></li><li><p>组合继承</p><ul><li>通过原型设置获取父类型的方法，修正constructor</li><li>通过call（）获取夫类型的属性</li></ul></li></ul><h3 id="this对象" tabindex="-1"><a class="header-anchor" href="#this对象" aria-hidden="true">#</a> this对象</h3><ul><li>如果一个标准函数作为某个对象作为方法被调用，this表示这个对象。级联（对象a有对象b）的话一样，最终被哪个对象调用就是哪个对象</li><li>如果一个非标准函数（也就是箭头函数）被某个对象作为方法调用，this表示定义这个箭头函数的上下文，全局的话就是window</li><li>构造器方法中，this表示新创建的对象</li><li>全局函数中，this表示全局对象window</li><li>call（）、apply（）、bind（）中，如果有传递对象，那么会强制把this指向对象</li><li>事件的响应函数中，this表示触发响应的dom对象</li></ul><h3 id="常用内置对象" tabindex="-1"><a class="header-anchor" href="#常用内置对象" aria-hidden="true">#</a> 常用内置对象</h3><ul><li><p>String</p><ul><li>String原本是基本类型，为了方便操作，把它包装成复杂类型，有length之类的属性还有方法，是特殊的引用类型</li><li>过程：**创建一个临时变量temp = new String（）**把简单类型包装为复杂类型，把temp赋值给原来的String类型变量，再销毁temp</li><li>因为通过这种方式new的String变量是引用类型，内容存放在堆，栈内存存放的是内容在堆的地址，如果给变量重新赋值，会在堆重新开辟一块空间然后修改栈内存的地址为新空间的地址，而String本身的内容是不会改变的</li><li>indexOf（字符）、lastIndexOf（）获取字符的位置，没有就返回-1</li><li>charAt（index）根据index获取字符串对应位置的内容、str（index）</li><li>charCodeAt（index）根据index获取字符串对应位置的ASCII码，判断用户按下了哪个键，例如如果是97（a）就怎么操作</li><li>concat（）拼接，相当于+</li><li>substr（begin，length）截取字符串</li><li>replace（被替换的，去替换的），只替换一个</li><li>split（分隔符）转为数组，把分隔符去掉</li><li>toUpperCase（）、toLowerCase（）变换大小写</li></ul></li><li><p>Date</p><ul><li>Date（）是构造函数，new创建日期对象，无参获取当前系统时间，参数可以是年月（从0开始）日的数字，可以是字符串（yyyy-mm-dd h：m：s）</li><li>对象调用getFullYear（）、getMonth（）（0-11）、getDate（）、getDay（）（周日是0）、getHours（）、getMinutes（）、getSeconds（）</li><li>获取距离1970.1.1的毫秒（时间戳）：valueOf（）、getTime（）、直接var x = +new Date（）（+和new连着）、直接Date.now（）。倒计时效果的实现：通过now（）和+new Date（一个指定的时间例如&#39;2022-6-1 00:00:00&#39;）相减，然后计算出d、h、m、s</li></ul></li><li><p>Array</p><ul><li><p>instanceof运算符，例如用于判断传入的是不是数组：name instanceof Array</p></li><li><p>isArray（），判断传入的是不是数组</p></li><li><p>push（），在数组末尾添加多个值，逗号隔开，返回数组新长度</p></li><li><p>unshift（）在数组前端添加多个值</p></li><li><p>pop（），删除最后一个元素，返回删除的元素</p></li><li><p>shift（），删除第一个元素</p></li><li><p>reverse（）翻转数组</p></li><li><p>sort（）排序数组，内部写function（a，b）{return a-b}就是升序（从小到大）</p></li><li><p>indexOf（数组元素的值，起始位置）获取索引编号，找不到就返回-1、lastIndexOf（）返回一样的结果，只是从后往前找。</p><p>数组去重（生成新的数组，遍历原本的数组，如果返回值是-1，就说明没有，就往新数组里面加）</p></li><li><p>toString（）、join（）都是将数组转为字符串，但是join可以选择分隔符，toString只有逗号</p></li><li><p>concat（）连接两个数组，返回新的数组</p></li><li><p>slice（begin，end）截取数组，返回新的数组</p></li><li><p>splice（开始，数量）在原有数组上删除个数，返回删除的值</p></li><li><p>filter（function（x）{ return true/false}）返回一个数组，包含return true的数组元素。x表示数组的每一项，就是arr[i]，return true还是false就看x和条件匹不匹配了。相当于遍历数组，每一个数组元素都做一次判断true和false，并记录下来每个数组元素的true和false，最后再找到为true的数组元素组成新数组</p></li></ul></li><li><p>Math</p><ul><li>Math对象不是构造函数，是静态的，直接用对象的数值和方法</li><li>max（）最大值，如果传一个参数，返回的的是那个参数，说明是在和负无穷比，参数无论如何都更大。所以<strong>不传参数返回-infinity</strong></li><li>abs（）绝对值</li><li>floor（）向下取整</li><li>ceil（）向上取整</li><li>round（）四舍五入，其中.5特殊，谁大取谁，比如-1.5，round之后是-1</li><li>random（）随机数【0，1），想要min和max中的随机整数：max-min+1得到数字个数，数字个数*随机数，因为随机数【0，1），所以相乘的结果的范围是【0，数字个数max-min+1），然后再加上min，就是【min，max+1），再用floor向下取整得到的就是【min，max】的整数</li></ul></li></ul><h2 id="dom-api" tabindex="-1"><a class="header-anchor" href="#dom-api" aria-hidden="true">#</a> DOM API</h2><p>DOM API提供操作页面（文档）对象的属性和方法</p><h3 id="dom操作步骤" tabindex="-1"><a class="header-anchor" href="#dom操作步骤" aria-hidden="true">#</a> DOM操作步骤</h3><p>获取事件源、选择事件类型、选择处理方法。如：btn.onclick = function(){}</p><h5 id="获取元素" tabindex="-1"><a class="header-anchor" href="#获取元素" aria-hidden="true">#</a> 获取元素</h5><p>getElementById（）、getElementByTagName（）、getElementByClassName（）、根据选择器获取一个querySelector（）、querySelectorAll（）、document.body、document.documentElement</p><h5 id="事件类型" tabindex="-1"><a class="header-anchor" href="#事件类型" aria-hidden="true">#</a> 事件类型</h5><p>onclick（）、移动onmousemove（）、onmouseout（）、经过onmouseover（）、onfocus（）、onblur（）、onmouseup（）、onmousedown（）、onmouseenter（）（enter不会冒泡，over会冒泡，所以如果给父元素设置over的事件，经过父元素会触发事件，经过子元素虽然不会触发，但是冒泡到父元素就触发了）、mouseleave（）</p><h5 id="处理-增删查改" tabindex="-1"><a class="header-anchor" href="#处理-增删查改" aria-hidden="true">#</a> 处理（增删查改）</h5><h6 id="处理元素" tabindex="-1"><a class="header-anchor" href="#处理元素" aria-hidden="true">#</a> 处理元素</h6><ul><li>获取、修改元素内容：innerText、innerHTML。innerText不识别html标签，会自动去除空格换行等</li><li>获取、修改元素属性： <ul><li>自带属性：DOM元素.属性名</li><li>自定义属性：DOM元素.getAttribute（属性），可以用data-开头，会自动放到dataset数组里面。DOM元素.setAttribute（属性，值）。经常搭配数组使用，给对象数组<strong>添加index属性</strong>，方便通过index绑定多个数组。removeAttribute（）删除属性</li></ul></li><li>修改元素样式： <ul><li>DOM元素.style，通过F12查看可以发现js写的style的样式会在行内，权重较高</li><li>DOM元素.className（），在css写好一个类的属性，在js给选中的对象设置className（会覆盖）。一组按钮选中变色，清除所有按钮，然后给this设置className</li><li>DOM元素.classList对象，可以调用add（）添加，remove（）删除，toggle（）有去无加</li></ul></li></ul><h6 id="处理节点" tabindex="-1"><a class="header-anchor" href="#处理节点" aria-hidden="true">#</a> 处理节点</h6><ul><li>节点类型：元素nodeType=1、属性2、文本3</li><li>获取相关节点： <ul><li>父节点：parentNode</li><li>子节点：childNodes（所有节点类型，不好用）、children（子元素节点，好用）、firstChild、firstElementChild、children[i]（常用）</li><li>兄弟节点：nextSibling（所有节点类型）、previousSibling、nextElementSibling</li></ul></li><li>创建节点： <ul><li>document.write（），直接将内容写入页面，当文档流执行完毕再调用write（），会<strong>导致页面重绘（开新页面）</strong></li><li>document.createElement（），父节点.appendChild（在最后添加子节点）、insertBefore（子节点，谁前面），通过createElement（）大约20ms</li><li>通过innerHTML创建，将内容写入某个DOM节点，不会导致页面重绘。如果有多个内容要添加，可以通过拼接字符串但是很慢3000ms。也可以先把各个要<strong>拼接的内容存到数组，然后数组调用join（‘’）方法</strong>，不超过10ms，最快，例如调转字符串，split把字符串变成数组然后reverse然后join</li></ul></li><li>删除节点：节点.removeChild（子节点）</li><li>复制节点：节点.cloneNode（），然后appendChild（）。括号内为空或false是浅拷贝，只复制节点本身，不复制子节点。true为深拷贝</li></ul><h3 id="事件注册" tabindex="-1"><a class="header-anchor" href="#事件注册" aria-hidden="true">#</a> 事件注册</h3><ul><li>传统方式：btn.onclick = function(){}，特点：唯一性，同一个元素同一个事件只能设置一个处理函数</li><li>监听方式：addEventListner（事件类型没有on，事件处理函数，useCapture），同一个元素同一个事件可以设置多个监听器，按顺序执行</li></ul><h3 id="事件解绑" tabindex="-1"><a class="header-anchor" href="#事件解绑" aria-hidden="true">#</a> 事件解绑</h3><ul><li>传统方式：btn.onclick = null</li><li>监听方式：removeEventListner（事件类型没有on，事件处理函数，useCapture），需要指定移除哪个函数，所以不能用匿名函数了。不解绑的话容易造成内存泄漏</li></ul><h3 id="事件流-捕获-冒泡" tabindex="-1"><a class="header-anchor" href="#事件流-捕获-冒泡" aria-hidden="true">#</a> 事件流（捕获/冒泡）</h3><p>捕获阶段、冒泡阶段。给某个元素注册了事件，捕获阶段从document开始一层一层往下传播点击事件，有就执行。找到之后依次把事件传播上去</p><p>只能执行<strong>捕获阶段或者冒泡阶段</strong>，通过useCapture设置，true是捕获阶段，不然默认冒泡。</p><p>onclick只有冒泡，而onblur、onfocus、onmousemove、onmouseout没有冒泡</p><h3 id="事件对象event" tabindex="-1"><a class="header-anchor" href="#事件对象event" aria-hidden="true">#</a> 事件对象event</h3><p>有事件就自动创建，不需要传参，用于记录事件的相关信息。有兼容问题，可以用window.event||event解决</p><p>对象的属性和函数：</p><ul><li>event.target，记录<strong>触发事件</strong>的对象。this是<strong>绑定事件</strong>的对象，target是触发事件的对象，也就是点了谁、操作了谁</li><li>event.preventDefault（）<strong>阻止默认行为</strong>，return false只能用在传统方式，并且会导致后面的无法执行</li><li>event.stopPropagation（），阻止冒泡</li></ul><h3 id="事件委托" tabindex="-1"><a class="header-anchor" href="#事件委托" aria-hidden="true">#</a> 事件委托</h3><p>事件委托的核心思想：不是给每个子元素设置dom操作，而是<strong>对他们的父元素注册监听事件</strong>（把事件都委托给他们的父亲），点击子元素后事件冒泡到父节点进行事件处理。通过target可以找到触发事件的对象，知道操作的是哪个子节点</p><h3 id="鼠标事件" tabindex="-1"><a class="header-anchor" href="#鼠标事件" aria-hidden="true">#</a> 鼠标事件</h3><p>click、mousemove、mouseout、mouseover、focus、blur、mouseup、mousedown、取消右键菜单：contextmenu事件的处理中阻止默认行为、event.preventDefault（）、禁止鼠标选取：selectStart事件的处理中阻止默认行为</p><p>鼠标事件对象的属性：</p><ul><li>clientX、clientY：鼠标相对于可视窗口的坐标</li><li>pageX、pageY：鼠标相对于页面文档document的坐标。可用于设置鼠标跟随</li></ul><h3 id="键盘事件" tabindex="-1"><a class="header-anchor" href="#键盘事件" aria-hidden="true">#</a> 键盘事件</h3><p>keyup、keydown、keypress（press不能识别功能按键例如alt、箭头等），顺序：down - press - up，怕影响别的都是设置up。例如设置按s聚焦搜索框，设置了keydown的监听事件，当down之后就会把s输入到搜索框内。很多实际的按钮也是<strong>松开才确认</strong></p><p>键盘事件对象的属性：</p><ul><li>key获取点击的按键值</li><li>keyCode点击的按键的ASCII码，down和up不区分大小写，都是取大写的ASCII码，press区分大小写。常用ASCII码判断按下什么</li></ul><h3 id="获取和设置元素大小和位置" tabindex="-1"><a class="header-anchor" href="#获取和设置元素大小和位置" aria-hidden="true">#</a> 获取和设置元素大小和位置</h3><p>根据是否包括边框分成offset和client、scroll</p><h5 id="元素偏移量offset" tabindex="-1"><a class="header-anchor" href="#元素偏移量offset" aria-hidden="true">#</a> 元素偏移量offset</h5><p>功能</p><ul><li><p>获取<strong>有定位的</strong>父元素：offsetParent，没有就body</p></li><li><p>获取相对于<strong>有定位的</strong>父元素的元素偏移（位置）不带单位：obj.offsetLeft、obj.offsetTop</p></li><li><p>获取自身边框以内<strong>包括边框</strong>（content+padding+border）的宽度高度：obj.offsetWidth、obj.offsetHeight</p></li></ul><p>offset和style的区别</p><ul><li>style只能获取行内样式表的样式值，offset都行</li><li>style获取的是String有单位，offset<strong>获取的是Number</strong>，没有单位</li><li>style获取content，offset获取content+padding+border</li><li>style可读可写，offset<strong>只能读</strong>。<strong>获取用offset，修改用style</strong></li></ul><p>最主要功能：</p><ul><li>获取位置</li></ul><p>具体案例：实现点击拖动效果：绑定鼠标点击事件mousedown，event.clientX、clientY获取鼠标相对视窗的位置，通过offset获取鼠标点击的对象的offsetLeft、offsetTop，相减得到鼠标相对于点击的区域的位置。绑定鼠标移动事件mousemove，根据鼠标相对于点击的区域的位置和鼠标当前位置event.clientX、clientY计算出对象相对于视窗的位置，然后用style赋值。绑定鼠标松开事件mouseup，移除函数</p><h5 id="元素可视区client" tabindex="-1"><a class="header-anchor" href="#元素可视区client" aria-hidden="true">#</a> 元素可视区client</h5><p>功能</p><ul><li>获取上边框和左边框的宽度，不带单位：obj.clientLeft、obj.clientTop</li><li>获取内容和内边距的宽度高度：obj.clientWidth、obj.clientHeight</li></ul><p>最主要功能</p><ul><li>获取元素大小</li></ul><h5 id="元素滚动scroll" tabindex="-1"><a class="header-anchor" href="#元素滚动scroll" aria-hidden="true">#</a> 元素滚动scroll</h5><p>功能</p><ul><li>获取能滚动的元素内部，被隐藏的头部距离和左边距离，不带单位：obj.scrollLeft、obj.scrollTop <ul><li>注意事项：<strong>能滚动的对象</strong>才能看到数值，否则是0。例如a套着b，b是a的内容并且b的长度a装不下，那么a会有滚动条，a.scrollTop就是b超出a上部的长度，而b.scrollTop和b溢出a的没关系。可用于滚动到某个位置（scrollTop&gt;一个数）就修改样式</li><li>元素获取被隐藏的高度（元素触发scroll事件）用obj.scrollTop，页面获取被隐藏的高度（document触发scroll事件）用<strong>window.pageYOffset</strong></li></ul></li><li>获取内容去和内边距的宽度高度，不是盒子的大小，如果内容爆了会变大，client爆了就不会：obj.scrollWidth、obj.scrollHeight</li></ul><p>最主要功能</p><ul><li>获取滚动距离</li></ul><h2 id="bom-api" tabindex="-1"><a class="header-anchor" href="#bom-api" aria-hidden="true">#</a> BOM API</h2><p>BOM提供操作浏览器的属性和方法</p><h3 id="window对象" tabindex="-1"><a class="header-anchor" href="#window对象" aria-hidden="true">#</a> window对象</h3><p>顶级对象是window。BOM包括DOM，window包括document 。window对象是全局对象，定义在全局作用域的变量和函数会变成window对象的属性和方法，alert（）、prompt（）也是window的方法，对象如果是可以省略</p><h5 id="属性" tabindex="-1"><a class="header-anchor" href="#属性" aria-hidden="true">#</a> 属性</h5><ul><li>innerWidth，获取window的宽度</li></ul><h5 id="方法" tabindex="-1"><a class="header-anchor" href="#方法" aria-hidden="true">#</a> 方法</h5><ul><li>setTimeout（调用的函数，延时ms），隔了延迟后调用函数。这个函数调用属于回调函数：上一件事干完再回头调用那个函数，不是按照顺序执行</li><li>clearTimeout（timeout的对象名），停止计时器</li><li>setInterval（调用的函数，时间ms），每隔时间就调用函数。可以实现倒计时</li><li>clearInterval（timeout的对象名），停止计时器</li></ul><h3 id="window对象的事件" tabindex="-1"><a class="header-anchor" href="#window对象的事件" aria-hidden="true">#</a> window对象的事件</h3><ul><li><p>窗口加载事件：</p><ul><li>onload，等整个窗口加载后触发，只会以最后一个为准，可以用监听方式注册</li><li>DOMContentLoaded，等DOM加载完成就触发，不包括样式表、图片等</li></ul></li><li><p>窗口大小变化事件：</p><ul><li>onresize：窗口大小变化时触发，配合window.innerWidth或者document.body.clientWidth获取宽度设置响应式布局</li></ul></li><li><p>窗口滚动事件：</p><ul><li>onscroll：滚动条滚动时触发，不止是window有这个事件</li></ul></li></ul><h3 id="location对象" tabindex="-1"><a class="header-anchor" href="#location对象" aria-hidden="true">#</a> location对象</h3><p>用于获取或设置窗口的URL，location返回的是对象。常用于页面跳转</p><h5 id="属性-1" tabindex="-1"><a class="header-anchor" href="#属性-1" aria-hidden="true">#</a> 属性</h5><ul><li><p>href获取URL</p></li><li><p>search获取参数</p></li><li><p>host获取主机/ip</p></li></ul><h5 id="方法-1" tabindex="-1"><a class="header-anchor" href="#方法-1" aria-hidden="true">#</a> 方法</h5><ul><li>assign（）跳转到页面</li><li>replace（）替换页面，不能返回上一个页面</li><li>reload（）刷线页面</li></ul><h3 id="navigator对象" tabindex="-1"><a class="header-anchor" href="#navigator对象" aria-hidden="true">#</a> navigator对象</h3><p>用于获取浏览器相关信息</p><h5 id="属性-2" tabindex="-1"><a class="header-anchor" href="#属性-2" aria-hidden="true">#</a> 属性</h5><ul><li>userAgent，用于获取访问设备</li></ul><h3 id="history对象" tabindex="-1"><a class="header-anchor" href="#history对象" aria-hidden="true">#</a> history对象</h3><p>用于与浏览器历史记录进行交互</p><h5 id="方法-2" tabindex="-1"><a class="header-anchor" href="#方法-2" aria-hidden="true">#</a> 方法</h5><ul><li>back（）</li><li>forward（）</li><li>go（参数）参数是1表示前进1个页面，-1后退</li></ul><h4 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h4><h2 id="ajax" tabindex="-1"><a class="header-anchor" href="#ajax" aria-hidden="true">#</a> AJAX</h2><p>AJAX是一种技术，意思是<strong>异步的JS与XML</strong></p><p>特点是网页<strong>不需要刷新</strong>，向服务端发送http请求，也就是说<strong>异步请求</strong>。如搜索框提示、账号注册的检测、懒加载按需加载（滚到底就继续加载新东西，放上去某个地方才显示对应东西）等</p><p>需要了解原生的、jQuery、fetch函数、axios工具包这4种AJAX的发送方式，http协议相关，跨域等</p><h3 id="关于xml" tabindex="-1"><a class="header-anchor" href="#关于xml" aria-hidden="true">#</a> 关于XML</h3><p>XML是可拓展标记语言，用于存储数据和传输。与HTML不同，HTML有预定义标签，XML都是<strong>自定义标签</strong>，用于表示数据。最早的时候AJAX数据交换的时候就是用的就是XML格式的字符串，JS获取到服务器传过来的字符串解析提取数据进行处理。<strong>现在都是用JSON</strong>，轻量级，方便转换。</p><h3 id="ajax的特点" tabindex="-1"><a class="header-anchor" href="#ajax的特点" aria-hidden="true">#</a> AJAX的特点</h3><ul><li>优点 <ul><li>不需要刷新页面就能发送请求与服务端通信</li><li>允许根据事件来更新页面内容</li></ul></li><li>缺点 <ul><li>没有回退</li><li>存在跨域问题（向服务a请求的网页里不允许向服务b发送AJAX请求）</li><li>SEO不友好（搜索引擎优化），如果一个页面的数据是通过AJAX技术获取的，响应体是没有这部分的数据的，是靠js动态创建才有。所以如果是爬虫就爬不到这部分的数据，搜索就不好做</li></ul></li></ul><h3 id="关于http协议" tabindex="-1"><a class="header-anchor" href="#关于http协议" aria-hidden="true">#</a> 关于HTTP协议</h3><ul><li>请求报文 <ul><li>行：请求类型GET、URL路径（放有参数）、HTTP协议版本</li><li>头：键值对，记录Cookie、Host、User-Agent等，也可以自定义</li><li>空行</li><li>体：<strong>就是参数</strong>xxx=yyy&amp;xx=yy</li></ul></li><li>响应报文 <ul><li>行：HTTP协议版本、响应状态码、响应状态字符串</li><li>头：键值对</li><li>空行</li><li>体：html页面内容</li></ul></li></ul><h3 id="关于node-js与express框架" tabindex="-1"><a class="header-anchor" href="#关于node-js与express框架" aria-hidden="true">#</a> 关于Node.js与Express框架</h3><ul><li><p>Node.js是个应用程序，用于解析JS代码</p></li><li><p>使用Express服务端框架</p><ul><li><p>引入express框架</p><p>const express = require(&#39;express&#39;);</p></li><li><p>创建app应用对象</p><p>const app = express();</p></li><li><p><strong>创建路由规则</strong>（匹配URL路径响应内容包括响应头、体）</p><p>app.get(&#39;/&#39;, (request,response)=&gt;{</p><p>​ response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);//设置<strong>响应头</strong>，这句是允许跨域</p><p>​ response.send(&#39;HELLO AJAX&#39;); //设置<strong>响应体</strong>，如果想响应数据，不能直接放到send的参数中，只接收字符串和buffer。但是可以<strong>用JSON.stringify</strong>（）方法把<strong>JSON</strong>格式的数据（例如对象）变成<strong>字符串</strong></p><p>});</p></li><li><p>监听端口启动服务</p><p>app.listen(8000, ()=&gt;{ console.log(&quot;服务已启动，8000端口监听中&quot;) })</p></li><li><p>在控制台输入node js文件名，然后就启动了这个服务</p></li></ul></li><li><p>使用nodemon实现自动重启服务</p><ul><li>安装：npm install -g nodemon</li><li>安装之后如果不行，不要停止监听，用管理员打开powershell，输入set-ExecutionPolicy RemoteSigned，然后按Y，之后启动服务输入<strong>nodemon js</strong></li></ul></li></ul><h3 id="原生ajax发送请求" tabindex="-1"><a class="header-anchor" href="#原生ajax发送请求" aria-hidden="true">#</a> 原生AJAX发送请求</h3><ul><li><p>AJAX请求的步骤</p><ul><li><p>创建请求<strong>对象</strong>：const xhr = new XMLHttpRequest()；</p></li><li><p>初始化对象，设置请求方式和URL：xhr.open（‘GET’ , ‘http://127.0.0.1:8080/server’），</p><ul><li>非必须，设置<strong>请求头</strong>，setRequestHeader（‘键’，‘值’）。可以设置自定义的请求头，但是需要在服务器的路由规则里设置response.setHeader(&#39;Access-Control-Allow-Headers&#39;,&#39;*&#39;)</li></ul></li><li><p>发送：xhr.send()</p></li><li><p>事件绑定：xhr.onreadystatechange，readystate是xhr对象的属性，值有0，1，2，3，4，表示状态：未初始化，已调用open（），已调用send（），服务端返回了部分的结果，服务端返回了全部结果。每次变化都会触发事件，<strong>需要在状态变为4之后才处理服务器的结果</strong>即xhr.readyState === 4再到下一步操作</p><p>收到了响应后还要判断响应码是否为2xx，是的话说明成功就处理结果，如通过xhr.status获取状态码、response获取响应体</p></li></ul></li><li><p>请求的参数传递</p><ul><li>get请求需要传递参数就在URL里面写</li><li>post请求的参数写到send中</li></ul></li><li><p><strong>传递接收JSON数据</strong></p><ul><li>通过**parse（）**把response转为JSON类型</li><li>通过设置**xhr.responseType = &#39;json&#39;**自动转换，response直接就是json数据类型</li></ul></li><li><p>解决IE缓存：在参数中加入时间：Date.now()</p></li><li><p>超时与异常：在页面给xhr设置超时，<strong>xhr.timeout</strong> = 2000表示两秒后请求取消，并且通过ontimeout设置提示信息。还有onerror</p></li><li><p>手动取消请求：<strong>xhr.abort()</strong>，要把xhr设置为全局变量，不能在某个元素的事件里面创建了</p></li><li><p>解决重复请求：每次点击<strong>先把之前的请求取消，再发送新的请求</strong></p></li></ul><h3 id="axios发送ajax请求" tabindex="-1"><a class="header-anchor" href="#axios发送ajax请求" aria-hidden="true">#</a> axios发送AJAX请求</h3><ul><li>引入axios：访问https://github.com/axios/axios，就能找到通过script标签引入的办法</li><li>发送请求 <ul><li>get请求格式：axios.get（请求地址【，对象封装包括param对象（封装url参数）、headers请求头信息】）.then（response =&gt; {}） <ul><li>请求地址可以**用axios.defaults.baseURL = ’xxxx‘**来设置URL，然后请求地址就可以只写 ’/abc‘</li><li>get请求无法直接对请求体做设置</li><li>数据返回方式<strong>基于Promise</strong>，所以在后面调用.then（value =&gt; {}）进行处理</li></ul></li><li>post请求<strong>第二个参数是用响应体封装的对象也就是参数</strong>，请求体发的是json格式的字符串</li></ul></li><li>使用axios（）来发送请求，参数是一个对象，包括以下。要处理响应还是用.then（response =&gt; {}） <ul><li>请求方法method</li><li>请求地址url</li><li>url参数params</li><li>头信息headers</li><li>请求体参数data</li></ul></li></ul><h3 id="fetch-发送ajax请求" tabindex="-1"><a class="header-anchor" href="#fetch-发送ajax请求" aria-hidden="true">#</a> fetch（）发送AJAX请求</h3><p>fetch（地址，对象）函数属于全局对象，函数<strong>返回一个Promise对象</strong>。参数中的对象包括以下属性</p><ul><li>请求方法method</li><li>请求头headers，值是对象</li><li>请求体body，<strong>值是字符串，格式为’a=aa&amp;b=bb‘</strong></li></ul><h3 id="跨域与解决" tabindex="-1"><a class="header-anchor" href="#跨域与解决" aria-hidden="true">#</a> 跨域与解决</h3><ul><li><p>同源策略：协议、域名、端口号必须完全相同</p><ul><li>AJAX默认遵循同源策略，<strong>违背同源策略就是跨域</strong>。页面是从某个服务器来的，如果AJAX请求也是从那个服务器就行</li><li>满足同源策略的话send（）的参数中可以省略URL，只写斜杠和后面的</li></ul></li><li><p>解决跨域</p><ul><li><p>JSONP</p><ul><li><p><strong>只支持get请求</strong></p></li><li><p>工作原理：<strong>有标签本身就有跨域能力，如img、script</strong>。利用<strong>script标签的src属性</strong>发送请求。注意设置对应的规则的时候在send（）里面的内容要是一个js语句。script标签收到返回的js语句并进行处理。如果返回的不是js语句，js引擎解析不了</p></li><li><p>实例：鼠标失去焦点时通过JSONP实现跨域发送AJAX请求</p><p>输入框设置onblur</p><p>获取this.value作为参数发送</p><p><strong>创建script标签并设置src属性，添加到body中</strong>。在执行这个script标签的时候，请求src，最后response.send()返回的结果（js语句）被js解析执行：调用方法修改原本innerHTML为空的标签</p></li></ul></li><li><p>CORS</p><p>官方办法，可以支持各种请求类型。在服务端的响应头中添加键值对</p><ul><li>设置请求源（哪些网页可以发请求）：Access-Control-Allow-Origins</li><li>设置暴露出哪些头信息：Access-Control-Expose-Headers</li><li>设置请求是否可以携带验证信息：Access-Control-Allow-Credentials</li><li>设置请求允许的方法：Access-Control-Allow-Methods，默认是get和post，可以换成*</li><li>设置请求时可以设置的请求头（方便设置自定义的请求头）：Access-Control-Allow-Headers</li></ul></li></ul></li></ul></div><!--[--><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/base/js/ES6.html" class="" aria-label="ES6"><!--[--><!--]--><!----><span>ES6</span><!--[--><!--]--></a></span></p></nav><!--[--><!--]--><!----></main><!--]--></div><div class="search-page" role="search"><span class="search-close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="28" height="28" fill="currentColor"><path d="M224 416c-8.188 0-16.38-3.125-22.62-9.375l-192-192c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L224 338.8l169.4-169.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-192 192C240.4 412.9 232.2 416 224 416z"></path></svg></span><div class="gungnir-search-box"><input placeholder="$ grep ..." autocomplete="off" spellcheck="false" value><!----></div></div><div class="menu-btn-container"><div class="menu-btn-wrapper"><div class="menu-btn"><div style="" class="menu-btn-icon"><span></span><span></span><span></span></div><div style="display:none;" class="menu-text">0</div><svg class="menu-progress"><circle class="menu-border" cx="50%" cy="50%" r="48%" style="stroke-dasharray:0% 314.15926%;"></circle></svg></div><div class="menu-btn-child-wrapper"><div title="toggle color mode" class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"/></svg><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 00283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"/></svg><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.66-53.33L160 80l-53.34-26.67L80 0 53.34 53.33 0 80l53.34 26.67L80 160zm352 128l-26.66 53.33L352 368l53.34 26.67L432 448l26.66-53.33L512 368l-53.34-26.67L432 288zm70.62-193.77L417.77 9.38C411.53 3.12 403.34 0 395.15 0c-8.19 0-16.38 3.12-22.63 9.38L9.38 372.52c-12.5 12.5-12.5 32.76 0 45.25l84.85 84.85c6.25 6.25 14.44 9.37 22.62 9.37 8.19 0 16.38-3.12 22.63-9.37l363.14-363.15c12.5-12.48 12.5-32.75 0-45.24zM359.45 203.46l-50.91-50.91 86.6-86.6 50.91 50.91-86.6 86.6z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z"/></svg></div><!----><div class="toggle-sidebar-button menu-btn-child menu-btn-sidebar" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-1.6 -1.6 19.2 19.2" fill="currentColor"><path d="M14 2a1 1 0 011 1v10a1 1 0 01-1 1H2a1 1 0 01-1-1V3a1 1 0 011-1h12zM2 1a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V3a2 2 0 00-2-2H2z"/><path d="M3 4a1 1 0 011-1h2a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4z"/></svg></div></div></div></div><!----></div><!--]--></div>
    <script type="module" src="/assets/app.4afcc58d.js" defer></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>vue | </title><meta name="description" content="">
    <link rel="modulepreload" href="/assets/app.4afcc58d.js"><link rel="modulepreload" href="/assets/vue.html.2ec71294.js"><link rel="modulepreload" href="/assets/vue.html.16fcb2f8.js"><link rel="prefetch" href="/assets/index.html.336290ef.js"><link rel="prefetch" href="/assets/css.html.506e1593.js"><link rel="prefetch" href="/assets/js.html.a0bf57de.js"><link rel="prefetch" href="/assets/vue.html.84befb48.js"><link rel="prefetch" href="/assets/docker.html.e8d84372.js"><link rel="prefetch" href="/assets/webpack.html.beed4981.js"><link rel="prefetch" href="/assets/index.html.424547b0.js"><link rel="prefetch" href="/assets/http.html.c64f9040.js"><link rel="prefetch" href="/assets/WebSocket.html.397bc3fc.js"><link rel="prefetch" href="/assets/浏览器.html.3be9ac20.js"><link rel="prefetch" href="/assets/设计模式.html.6cbb97f1.js"><link rel="prefetch" href="/assets/gungnir博客配置.html.39a6fc28.js"><link rel="prefetch" href="/assets/nuxt.html.ffd9bbf8.js"><link rel="prefetch" href="/assets/css.html.ed27349b.js"><link rel="prefetch" href="/assets/html.html.5d591db3.js"><link rel="prefetch" href="/assets/ES6.html.d18c8b41.js"><link rel="prefetch" href="/assets/js基础.html.d9c4f284.js"><link rel="prefetch" href="/assets/js文件处理.html.c503b127.js"><link rel="prefetch" href="/assets/ts.html.04aa003e.js"><link rel="prefetch" href="/assets/404.html.7d858b3d.js"><link rel="prefetch" href="/assets/index.html.de26035a.js"><link rel="prefetch" href="/assets/index.html.deae5fb3.js"><link rel="prefetch" href="/assets/index.html.4cb84524.js"><link rel="prefetch" href="/assets/css.html.93508d1c.js"><link rel="prefetch" href="/assets/js.html.fc6d541f.js"><link rel="prefetch" href="/assets/vue.html.3c6162b9.js"><link rel="prefetch" href="/assets/docker.html.bbb72b70.js"><link rel="prefetch" href="/assets/webpack.html.84c1a7de.js"><link rel="prefetch" href="/assets/index.html.3b7f3b90.js"><link rel="prefetch" href="/assets/http.html.9621d1aa.js"><link rel="prefetch" href="/assets/WebSocket.html.7c6ff825.js"><link rel="prefetch" href="/assets/浏览器.html.a2b666bb.js"><link rel="prefetch" href="/assets/设计模式.html.7377c483.js"><link rel="prefetch" href="/assets/gungnir博客配置.html.7938d25f.js"><link rel="prefetch" href="/assets/nuxt.html.6dd0db5d.js"><link rel="prefetch" href="/assets/css.html.225aaa80.js"><link rel="prefetch" href="/assets/html.html.f56f005d.js"><link rel="prefetch" href="/assets/ES6.html.b981eacd.js"><link rel="prefetch" href="/assets/js基础.html.81abd258.js"><link rel="prefetch" href="/assets/js文件处理.html.9a722572.js"><link rel="prefetch" href="/assets/ts.html.f117f106.js"><link rel="prefetch" href="/assets/404.html.55b7a351.js"><link rel="prefetch" href="/assets/index.html.5977f679.js"><link rel="prefetch" href="/assets/index.html.b927cf80.js"><link rel="prefetch" href="/assets/404.c52688da.js"><link rel="prefetch" href="/assets/HomePage.4b2e5824.js"><link rel="prefetch" href="/assets/Layout.8b63924c.js"><link rel="prefetch" href="/assets/Links.a9ebced6.js"><link rel="prefetch" href="/assets/Post.3484b530.js"><link rel="prefetch" href="/assets/Tags.61676cf8.js">
    <link rel="stylesheet" href="/assets/style.d9da5232.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar is-fixed is-visible invert"><span><a href="/" class=""><span class="site-name">BWLLzlx的个人博客</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--><!----><span>首页</span><!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="基础"><span class="title"><!----><span>基础</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="基础"><span class="title"><!----><span>基础</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/base/h5c3/html.md" class="" aria-label="h5c3"><!--[--><!--]--><!----><span>h5c3</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/base/js/js基础.md" class="" aria-label="js"><!--[--><!--]--><!----><span>js</span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Vue框架"><span class="title"><!----><span>Vue框架</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Vue框架"><span class="title"><!----><span>Vue框架</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/vue/vue.md" class="" aria-label="vue"><!--[--><!--]--><!----><span>vue</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/vue/nuxt.md" class="" aria-label="服务端渲染"><!--[--><!--]--><!----><span>服务端渲染</span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工程化"><span class="title"><!----><span>工程化</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工程化"><span class="title"><!----><span>工程化</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/engineer/docker.md" class="" aria-label="docker"><!--[--><!--]--><!----><span>docker</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/engineer/webpack.md" class="" aria-label="webpack"><!--[--><!--]--><!----><span>webpack</span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="知识体系完善"><span class="title"><!----><span>知识体系完善</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="知识体系完善"><span class="title"><!----><span>知识体系完善</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/pro/浏览器.md" class="" aria-label="浏览器"><!--[--><!--]--><!----><span>浏览器</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pro/http.md" class="" aria-label="http协议"><!--[--><!--]--><!----><span>http协议</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pro/WebSocket.md" class="" aria-label="WebSocket协议"><!--[--><!--]--><!----><span>WebSocket协议</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pro/设计模式.md" class="" aria-label="设计模式"><!--[--><!--]--><!----><span>设计模式</span><!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--><!----><span>首页</span><!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="基础"><span class="title"><!----><span>基础</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="基础"><span class="title"><!----><span>基础</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/base/h5c3/html.md" class="" aria-label="h5c3"><!--[--><!--]--><!----><span>h5c3</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/base/js/js基础.md" class="" aria-label="js"><!--[--><!--]--><!----><span>js</span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Vue框架"><span class="title"><!----><span>Vue框架</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Vue框架"><span class="title"><!----><span>Vue框架</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/vue/vue.md" class="" aria-label="vue"><!--[--><!--]--><!----><span>vue</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/vue/nuxt.md" class="" aria-label="服务端渲染"><!--[--><!--]--><!----><span>服务端渲染</span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="工程化"><span class="title"><!----><span>工程化</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="工程化"><span class="title"><!----><span>工程化</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/engineer/docker.md" class="" aria-label="docker"><!--[--><!--]--><!----><span>docker</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/engineer/webpack.md" class="" aria-label="webpack"><!--[--><!--]--><!----><span>webpack</span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="知识体系完善"><span class="title"><!----><span>知识体系完善</span></span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="知识体系完善"><span class="title"><!----><span>知识体系完善</span></span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/pro/浏览器.md" class="" aria-label="浏览器"><!--[--><!--]--><!----><span>浏览器</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pro/http.md" class="" aria-label="http协议"><!--[--><!--]--><!----><span>http协议</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pro/WebSocket.md" class="" aria-label="WebSocket协议"><!--[--><!--]--><!----><span>WebSocket协议</span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/pro/设计模式.md" class="" aria-label="设计模式"><!--[--><!--]--><!----><span>设计模式</span><!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">vue <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vue/vue.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="vue"><!--[--><!--]--><!----><span>vue</span><!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vue/vue.html#vue-2" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 2"><!--[--><!--]--><!----><span>Vue 2</span><!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vue/vue.html#vue基础" class="router-link-active router-link-exact-active sidebar-item" aria-label="vue基础"><!--[--><!--]--><!----><span>vue基础</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue/vue.html#vue组件化编程" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue组件化编程"><!--[--><!--]--><!----><span>Vue组件化编程</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue/vue.html#vue-cli脚手架" class="router-link-active router-link-exact-active sidebar-item" aria-label="vue-cli脚手架"><!--[--><!--]--><!----><span>vue-cli脚手架</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue/vue.html#vue中的ajax" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue中的AJAX"><!--[--><!--]--><!----><span>Vue中的AJAX</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue/vue.html#vuex保存数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="vuex保存数据"><!--[--><!--]--><!----><span>vuex保存数据</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue/vue.html#vue-router前端路由" class="router-link-active router-link-exact-active sidebar-item" aria-label="vue-router前端路由"><!--[--><!--]--><!----><span>vue-router前端路由</span><!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vue/vue.html#vue-3" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue 3"><!--[--><!--]--><!----><span>Vue 3</span><!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vue/vue.html#和vue2的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="和Vue2的区别"><!--[--><!--]--><!----><span>和Vue2的区别</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue/vue.html#创建vue3工程" class="router-link-active router-link-exact-active sidebar-item" aria-label="创建Vue3工程"><!--[--><!--]--><!----><span>创建Vue3工程</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue/vue.html#vue3工程结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="Vue3工程结构"><!--[--><!--]--><!----><span>Vue3工程结构</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue/vue.html#常用composition-api" class="router-link-active router-link-exact-active sidebar-item" aria-label="常用Composition API"><!--[--><!--]--><!----><span>常用Composition API</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue/vue.html#其他composition-api" class="router-link-active router-link-exact-active sidebar-item" aria-label="其他Composition API"><!--[--><!--]--><!----><span>其他Composition API</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue/vue.html#composition-api的优势" class="router-link-active router-link-exact-active sidebar-item" aria-label="Composition API的优势"><!--[--><!--]--><!----><span>Composition API的优势</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue/vue.html#新的组件" class="router-link-active router-link-exact-active sidebar-item" aria-label="新的组件"><!--[--><!--]--><!----><span>新的组件</span><!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vue/vue.html#其他" class="router-link-active router-link-exact-active sidebar-item" aria-label="其他"><!--[--><!--]--><!----><span>其他</span><!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="/vue/nuxt.html" class="sidebar-item" aria-label="nuxt"><!--[--><!--]--><!----><span>nuxt</span><!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><div class="page-content"><!--[--><main class="page"><!--[--><div class="article-header" style=""><!----><div class="article-header-content"><!----><h1 class="article-title">vue</h1><!----><div class="article-icons"><div class="article-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M313.6 304c-28.7 0-42.5 16-89.6 16-47.1 0-60.8-16-89.6-16C60.2 304 0 364.2 0 438.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-25.6c0-74.2-60.2-134.4-134.4-134.4zM400 464H48v-25.6c0-47.6 38.8-86.4 86.4-86.4 14.6 0 38.3 16 89.6 16 51.7 0 74.9-16 89.6-16 47.6 0 86.4 38.8 86.4 86.4V464zM224 288c79.5 0 144-64.5 144-144S303.5 0 224 0 80 64.5 80 144s64.5 144 144 144zm0-240c52.9 0 96 43.1 96 96s-43.1 96-96 96-96-43.1-96-96 43.1-96 96-96z"/></svg><span>BWLLzlx</span></div><!----><div class="article-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M17.618 5.968l1.453-1.453 1.414 1.414-1.453 1.453a9 9 0 11-1.414-1.414zM12 20a7 7 0 100-14 7 7 0 000 14zM11 8h2v6h-2V8zM8 1h8v2H8V1z"/></svg><span>57 min</span></div></div></div><!----></div><!--[--><!--]--><!--]--><div class="theme-gungnir-content"><!--[--><!--]--><div><h2 id="vue-2" tabindex="-1"><a class="header-anchor" href="#vue-2" aria-hidden="true">#</a> Vue 2</h2><h3 id="vue基础" tabindex="-1"><a class="header-anchor" href="#vue基础" aria-hidden="true">#</a> vue基础</h3><h4 id="vue简介" tabindex="-1"><a class="header-anchor" href="#vue简介" aria-hidden="true">#</a> Vue简介</h4><p>vue是用于<strong>构建用户界面</strong>的<strong>渐进式</strong>JS框架</p><ul><li>构建用户界面：前端的工作就是在合适的时候，发出合适的请求，把数据展示在合适的位置</li><li>渐进式：可以从只引入核心库，到引入各种Vue插件</li></ul><p>特点：</p><ul><li><strong>组件化</strong>，封装提高复用便于维护</li><li><strong>声明式编码</strong>。传统是命令式编码，按照步骤一步一步执行。声明式编码可以直接简化流程，<strong>不需要直接操作DOM</strong></li><li>虚拟DOM和比较算法Diff <ul><li>原生JS中，123三条数据变成1234四条数据，<strong>把123全清理再添加1234</strong></li><li>在Vue中，在把数据存储到真实DOM之前，先把数据放到虚拟DOM中。当数据发生改变，<strong>虚拟DOM会将新的和旧的做对比，哪不一样就操作真实DOM</strong>，一样的就复用</li></ul></li></ul><p>安装vue方式：</p><ul><li>script标签。引入之后，<strong>全局多了一个叫做Vue的构造函数</strong></li><li>npm</li></ul><h4 id="hello-world" tabindex="-1"><a class="header-anchor" href="#hello-world" aria-hidden="true">#</a> Hello World</h4><ul><li>先<strong>创建容器</strong>，整个容器称作模板</li><li>再<strong>创建Vue实例</strong>，需要传入配置对象options。Vue实例开始工作时，配置的el属性<strong>绑定了Vue实例为哪个容器服务</strong>，把容器的<strong>内容获取</strong>并且解析内部的<strong>Vue的特殊的模板语法</strong>，例如，会计算内容替换成正常的HTML片段</li><li>计算特殊语法后<strong>生成一个新的容器，替换掉原来的模板</strong></li><li><strong>实例和容器之间一一对应</strong>。容器找到了一个实例之后就不会管别人了，容器有了实例管理之后就不会再接收别人管了</li><li>插值语法中要写js表达式，js表达式是指<strong>会得到一个值</strong>的js语句</li><li>可以在开发者工具看到<strong>Vue实例Root</strong></li></ul><h4 id="模板语法" tabindex="-1"><a class="header-anchor" href="#模板语法" aria-hidden="true">#</a> 模板语法</h4><ul><li>插值语法，用于<strong>解析标签体内容</strong>，要写js表达式</li><li>指令语法 ，<strong>插值语法不能用于标签属性。指令语法用于解析标签【包括标签属性、标签体内容、绑定事件等】</strong>，形式为v-xxx <ul><li>v-bind：加在属性前，让被选中的属性值<strong>被解析为表达式</strong>而不是直接取字符串值。例如v-bind：href = “abc”，解析后href属性会取到abc<strong>表达式的值</strong>而不是字符串“abc”。v-bind：可以缩写为【：】</li><li>v-model：双向绑定</li><li>v-on：绑定事件</li></ul></li></ul><h4 id="数据绑定" tabindex="-1"><a class="header-anchor" href="#数据绑定" aria-hidden="true">#</a> 数据绑定</h4><ul><li>单向绑定：【v-bind：】，缩写为【：】。数据从data流向页面。能把data中的数据<strong>绑定给某个DOM元素</strong>。但是DOM元素发生更改，v-bind设置的<strong>data中的数据不会变</strong>。当data中的数据发生改变，实例需要重新阅读模板进行解析，然后<strong>所有用到data的DOM元素都会改变</strong>，所有<strong>函数也要重新计算返回结果</strong></li><li>双向绑定：【v-model：value】，缩写为【v-model】用在表单类元素上，能够双向改变获取值，因为需要本身能够输入，<strong>所以需要本身有value属性</strong></li></ul><h4 id="el与data的写法" tabindex="-1"><a class="header-anchor" href="#el与data的写法" aria-hidden="true">#</a> el与data的写法</h4><ul><li><p>el绑定容器的写法：</p><ul><li><p>el：“选择器”</p></li><li><p><strong>Vue实例对象调用$mount（“选择器”）</strong>，这是Vue原型的方法，更加灵活</p></li></ul></li><li><p>data的写法：</p><ul><li>对象式写法，data：{属性键值对}</li><li>函数式写法：data：function（）{return {属性键值对} }，<strong>调用这个函数的是Vue实例</strong>，<strong>Vue管理的函数不要用箭头函数，否则this指向Window而不是Vue实例</strong>。也可以写成data（）{return {} }</li></ul></li></ul><h4 id="mvvm模型" tabindex="-1"><a class="header-anchor" href="#mvvm模型" aria-hidden="true">#</a> MVVM模型</h4><ul><li>M：Model，模型，指data数据</li><li>V：View，视图，指DOM元素，模板代码</li><li>VM：ViewModel，指Vue实例，<strong>负责将M和V建立关系，把数据和元素建立起联系</strong>。内部实现了对DOM的监听和拿数据对DOM进行绑定</li></ul><p>data中的属性最后都出现在Vue实例中。<strong>data的属性和Vue原型的所有属性都能在Vue模板代码中使用</strong></p><h4 id="数据代理" tabindex="-1"><a class="header-anchor" href="#数据代理" aria-hidden="true">#</a> 数据代理</h4><p>了解函数Object.defineProperty（对象，属性，配置对象）：</p><ul><li><p>配置对象包括配置项value、enumerable可枚举、writable可修改、configurable可删除</p></li><li><p>还有配置项get：function（）、set：function（）。getter在当前<strong>属性被读取时调用，return值会成为属性的值</strong>。setter在修改当前属性时调用，<strong>会得到被修改的值</strong>。能够通过defineProperty（）把<strong>数据和对象进行关联</strong></p></li></ul><p>数据代理的原理：</p><p>通过<strong>对象a操作对象b的属性</strong>，利用defineProperty（）。让a代理b的x属性，那就给a添加属性x，给a获取和设置都是操作b的值。defineProperty（a，‘x’，配置对象{ getter，setter }），<strong>getter就return b的x，setter就把b.x = value</strong></p><p>MVVM中的数据代理，data ~~~ _data ~~~ Vue实例：</p><p>之所以代码中data的属性会出现在Vue实例，就是因为**调用了Object.defineProperty（）**给Vue实例添加了这些属性，做了数据代理</p><p><strong>代码中data部分的数据</strong>会被保存在Vue实例（之后称作vm）的**_data属性<strong>中，是先保存到_data中，再用Vue实例给_data的属性做数据代理，而</strong>不是直接给data做代理**。获取Vue实例的属性，会调用getter获取_data里面的属性；设置Vue实例的属性，会调用setter去设置_data里面的属性。<strong>当_data中的某个属性发生变化，还会自动去修改data的值</strong>，靠的是对_data的一番升级来实现，称作【数据劫持】，后续讲解</p><h4 id="事件处理" tabindex="-1"><a class="header-anchor" href="#事件处理" aria-hidden="true">#</a> 事件处理</h4><p>语法：给模板代码中的标签绑定事件，通过指令语法：例如单击事件【on：click】，缩写为【@click】</p><p>回调：回调函数<strong>写在Vue实例的配置对象的属性methods</strong>中，被Vue实例管理。并且<strong>由Vue实例vm来调用（this指向vm）</strong>。过程是当Vue实例解析模板代码发现需要执行某个函数时，就去调用这个函数</p><p>参数：不传参默认会传event，传了其他参数之后event会没，可以<strong>在传的时候传$event，这样能获取到event</strong></p><p>和data的差别：在methods添加的函数同样会被放到vm中，不过不需要做数据代理，因为<strong>函数内容不需要变更，数据要代理是因为数据要变更</strong></p><p>事件修饰符：事件修饰符加在@click的后方。<strong>原本需要由event进行调用一些方法，现在不需要</strong></p><ul><li>prevent：阻止默认行为</li><li>passive：默认行为会立即执行。原本的话是【先执行完回调再做默认行为，有时候如果回调要做好久就可以用得上passive】</li><li>stop：阻止事件冒泡到下一层</li><li>self：只有当event.target时候才能调用回调，也能阻止冒泡</li><li>once：事件只能触发一次</li></ul><p>键盘事件：</p><ul><li>键盘事件可以通过@keyup和keydown使用</li><li>vue提供了一些别名修饰进行绑定，例如tab、enter、space</li><li>没有提供别名的，可以用event.key值进行筛选绑定【统一用小写，多个单词中间用-进行分割】，也可以用keyCode【不推荐】</li><li>可以自定义别名：Vue.config.keyCodes.自定义别名 = keyCode</li><li>如果是shift、alt、win、ctrl这种<strong>系统功能键，配合keydown来用</strong>，否则可能会执行别的而<strong>没有执行回调</strong>。可以在系统修饰键后面再加普通键，可以实现<strong>需要同时按下</strong></li></ul><h4 id="计算属性" tabindex="-1"><a class="header-anchor" href="#计算属性" aria-hidden="true">#</a> 计算属性</h4><p>计算属性是computed，也是一个受Vue管理的对象，用于<strong>需要通过已有属性计算的变量</strong>。computed内部也是存取数据对象，每个<strong>数据对象有getter和setter</strong></p><p>每个<strong>计算属性在初次使用和用的变量发生改变</strong>时调用getter，<strong>优点是可以缓存</strong>，如果没变就不会再调用getter</p><p>计算属性也会被放到vm身上，是调用getter获取到返回值再放到vm中</p><p>简写：<strong>当这个计算属性不需要setter的时候才能简写</strong>。属性不再是一个对象，而是一个函数，就是那个<strong>getter函数的内容</strong>，但实际上这<strong>还是个属性</strong>，用的时候不要当作函数</p><h4 id="监视属性" tabindex="-1"><a class="header-anchor" href="#监视属性" aria-hidden="true">#</a> 监视属性</h4><p>监视属性是watch，也是受Vue管理的对象。watch里面的对象包括配置属性，<strong>包括handler方法</strong>，在对象发生改变的时候调用，传入的参数是旧值和新值。包括immediately属性，可以用于一开始调用handler初始化</p><p>写法：</p><ul><li>直接在Vue实例中配置</li><li>在创建好Vue实例后vm.$watch（属性名，对象【包括各种配置属性】）</li></ul><p>深度监视：watch默认<strong>不支持监视对象内部的值的改变</strong>，需要检测到内部值的改变，需要<strong>添加配置属性deep</strong></p><p>简写：<strong>被监视属性只需要handler配置属性</strong>的时候。这个属性的值就不再是个对象，而是函数，函数内容就是handler的内容</p><h4 id="计算属性和监视属性的区别" tabindex="-1"><a class="header-anchor" href="#计算属性和监视属性的区别" aria-hidden="true">#</a> 计算属性和监视属性的区别</h4><ul><li>计算属性<strong>写在computed</strong>。而监视属性监视到某个数据修改后，如果要修改某条数据，这个数<strong>在data</strong>里面</li><li>计算属性是靠computed里面的对象的getter获取的，<strong>需要return才得到</strong>。监视属性修改值就直接修改this.xxx，<strong>不需要return</strong></li><li><strong>计算属性不方便执行异步操作</strong>，因为要return。P.S.<strong>箭头函数的this是取当前函数作用域的this，所以如果有异步操作就用箭头函数，this还能指向vm</strong></li></ul><h4 id="绑定样式" tabindex="-1"><a class="header-anchor" href="#绑定样式" aria-hidden="true">#</a> 绑定样式</h4><p>通过【v-bind：】绑定class属性为data中xxx的值，<strong>通过xxx的值选择不同的类从而选择不同的样式</strong>。修改的时候只需要修改xxx就行</p><ul><li>值是字符串：适用于名字不确定</li><li>值是数组：适用于样式个数不确定、名字不确定</li><li>值是对象：需要都确定，但是需要动态决定用不用</li></ul><p>通过【v-bind：】绑定style属性，<strong>需要让内容为表达式</strong>，能得到一个值，所以<strong>在里面写一个对象</strong>。key就是普通的css的key，value就用data的数据</p><h4 id="条件渲染" tabindex="-1"><a class="header-anchor" href="#条件渲染" aria-hidden="true">#</a> 条件渲染</h4><p>v-if、v-else：v-if是直接删除和添加dom元素，不是display。if和else的用法就像<strong>正常的if-else，连着的就是一起的</strong></p><p>v-show：值为true就显示，值为false就隐藏。可以让值从data取，动态修改，写活。<strong>底层实现是display</strong></p><p>只有v-if能和template配合使用</p><p><strong>变化频繁的用v-show好一点</strong></p><h4 id="关于template" tabindex="-1"><a class="header-anchor" href="#关于template" aria-hidden="true">#</a> 关于template</h4><p><strong>template标签不会影响页面结构</strong>，对内容进行包裹，页面渲染的时候会把包裹去掉</p><h4 id="列表渲染" tabindex="-1"><a class="header-anchor" href="#列表渲染" aria-hidden="true">#</a> 列表渲染</h4><p>在data中把列表的数据放到数组里，<strong>数组存放对象</strong>，<strong>为了区分必须要有属性id</strong>。使用v-for属性来遍历对象</p><p>格式：v-for = “p in persons”，就是获取到每一个对象p，可以使用p.name、p.age这样的属性。可以获取多个值，例如v-for = “（p，index）in persons”，index就是数组下标。<strong>还要写【：key】相当于指定主键</strong>，唯一的区分。<strong>不写key的话，key默认会用value，但这样不好</strong></p><p>功能：v-for可用于遍历数组（p，index）、对象（value、key）、字符串</p><p>key：</p><ul><li>key在模板用，给Vue实例解析之后，<strong>得到的普通代码是没有key属性的</strong></li><li><strong>key用于虚拟DOM的Diff算法</strong>，<strong>比较新旧虚拟DOM相同key的标签的内容是否相同</strong>。相同就直接从真实DOM拿来用，不同就从新的虚拟DOM拿去用。如果【：key】用index，当<strong>列表顺序和数据存放的id顺序不同时，会因为Diff算法导致数据错位</strong>。如果用【p.id】就完全不会有这种问题，index值会因为排序而修改，而id不会，id始终绑定好了不怕对错位</li></ul><p>列表过滤：</p><ul><li><p>思想：<strong>双向绑定data的数据keyWord，获取输入的关键字，筛选得到新的列表</strong></p></li><li><p>实现：</p><ul><li><p>watch：监视keyWord，在data中添加数据newArr = []，当keyWord发生变化，用keyWord<strong>重新计算新数组</strong>赋值给newArr。搜索空的时候，可以得到全部，所以默认需要调用，也就是需要immediate</p></li><li><p>computed：在computed添加newArr，值是用keyWord过滤的新数组</p></li></ul></li></ul><p>列表排序：</p><p>排序和过滤是一起的。<strong>过滤得到的数组，不急着返回，先排序再返回</strong>。通过一个值记录0，1，2选择不排序，升序，降序。点击按钮修改这个值。再根据这个值进行排序</p><h4 id="数据监测" tabindex="-1"><a class="header-anchor" href="#数据监测" aria-hidden="true">#</a> 数据监测</h4><ul><li><p>对对象监测的原理：靠setter</p><p><strong>把data的数据放到vm._data之前，要先进行加工</strong>。定义Observer构造函数，在对象中获取data的属性，并且创建getter和setter，这样就算加工完成。这之后创建obs对象，然后把值赋给data和_data，之后再数据代理到vm</p><p>当obs中<strong>对象的data改变，会调用对应的setter重新解析模板，模板改变后生成新的虚拟DOM，然后和旧的虚拟DOM对比，生成新的结果</strong>。之所以能够监测data，就是由这个setter来实现</p></li><li><p>Vue.set（）方法：可以给**_data内部的对象【不能给_data，更不能给vm】**添加属性，参数是【对象，属性，值】。也可以用vm.$set（）</p><p>通过这样添加的原来没有的<strong>属性会是响应式的，也就是有getter和setter</strong></p></li><li><p><strong>通过数组下标修改</strong>数据不生效的原因：如果数据写成数组的形式，<strong>数组下标对应的值没有对应的getter和setter</strong>【例如这个数组arr是[obj1，obj2]，arr对象内没有第0项和第1项的getter和setter。但如果obj1里面有其他属性name和age，obj1对象内部是有age和name 的getter和setter的】。<strong>没setter</strong>就不能重新解析模板生成虚拟DOM比较更新</p><p><strong>要修改数组元素的话需要通过修改整个数组</strong>来修改。修改整个数组的办法有：push、pop、shift、unshift、reverse、sort、splice，这几个方法都是在原有数组上操作的，也就是原来是数组a，操作完之后得到不是新数组b。实际上Vue对这几个方法做了封装：先调用原生的版本，然后重新解析。也可以**通过Vue.set（）**去操作数组元素</p></li></ul><h4 id="表单数据收集" tabindex="-1"><a class="header-anchor" href="#表单数据收集" aria-hidden="true">#</a> 表单数据收集</h4><p>input的类型不同，v-model收集到的内容不同</p><ul><li>type是text，收集的是value，也就是输入</li><li>type是radio，收集的也是value，但是因为没有输入框，所以需要通过属性指定value</li><li>type是checkbox，理想情况下是收集value。<strong>如果没有value属性，就会收集checked属性</strong>。就算有了checked属性，如果想要接收value，必须要让checkbox<strong>接收数据的类型是数组</strong>，如果是字符串，就算有value，也只能接收true和false</li></ul><p>v-model的三个修饰符：</p><ul><li>number：绑定后从DOM<strong>传给data的数据变成number</strong>，不加的话默认是字符串</li><li>lazy：让绑定的不那么敏感，<strong>失去焦点才提交修改</strong></li><li>trim：去掉两边的空</li></ul><h4 id="过滤器" tabindex="-1"><a class="header-anchor" href="#过滤器" aria-hidden="true">#</a> 过滤器</h4><p>功能：对一个数据进行格式化或者操作【让一个数据经过函数处理得到另外的结果，<strong>原本数据不改变</strong>】</p><p>使用场景：在插值语法中。v-bind：中</p><p>使用格式：数据 | 函数名。将数据作为<strong>第一个参数</strong>调用函数，函数<strong>返回值作为表达式的值</strong>。可以使用多个过滤器：数据 | 函数名1 | 函数名2。函数2的参数是函数1的返回值</p><p>局部配置格式：在Vue配置对象中的filters下面写函数</p><p>全局配置格式：Vue.filter（过滤器名，函数）</p><h4 id="内置指令" tabindex="-1"><a class="header-anchor" href="#内置指令" aria-hidden="true">#</a> 内置指令</h4><p>旧</p><ul><li>v-bind</li><li>v-model</li><li>v-for</li><li>v-on</li><li>v-show</li><li>v-if、else</li></ul><p>新</p><ul><li><p>v-text：会<strong>替换掉整个节点中的内容</strong>，感觉不如……插值语法</p></li><li><p>v-html：和text对应，text会把所有内容解析为文本。html会解析标签语句。正因如此，<strong>会有安全性问题</strong>。例如写了个a标签跳转到其他网页，并且携带当前的cookie。其他用户点击时，将会<strong>带着自己的cookie数据访问另外的网页，信息泄露</strong></p></li><li><p>v-cloak：没有值，相当于一个标记，<strong>在Vue实例接管容器的瞬间，这个属性会被删掉</strong>。配合css使用实现：<strong>没请求到服务器的数据之前先不显示</strong></p><p>例如前100行前写界面，100-200请求数据，200-300是Vue实例。假如网络很慢，<strong>网页结构已经渲染好了</strong>，但因为数据还没收到导致阻塞，<strong>后面的Vue代码还没执行</strong>，这时候网页渲染出来的效果是模板语法，也就是什么的</p><p>给需要Vue渲染的模板片段加上v-cloak，因为<strong>只要有这个属性就说明还没被Vue接管，给这个标签设置样式例如display：none</strong>。当被Vue接管之后，属性消失，就不再display：none</p></li><li><p>v-once：v-once所在节点在<strong>第一次动态被Vue渲染后，就变成静态的</strong></p></li><li><p>v-pre：让Vue<strong>不操作当前节点，把模板原封不动</strong></p></li></ul><h4 id="自定义指令" tabindex="-1"><a class="header-anchor" href="#自定义指令" aria-hidden="true">#</a> 自定义指令</h4><p>功能：封装对DOM的操作</p><p>命名：用a-b-c格式</p><p>函数写法：directives，内部写指令作为方法或对象。指令名为x，使用的时候就用v-x</p><p>参数：elemnt使用指令的元素，binding指令对象（包括value、name等属性）。一个是DOM元素，一个是操作</p><p>调用时机：</p><ul><li>当指令和节点成功绑定的时候，也就是一开始就会调用一次</li><li><strong>模板被重新解析的时候</strong>，例如v-x=&quot;n&quot;，当n变了会导致模板重新解析，重新调用v-x。另外的节点用到了name数据，当name改变时，模板也会重新解析，虽然v-x没有用到name，但是也会重新调用</li></ul><p>对象写法：写成一个对象，内部包括常饮用方法：bind（）、inserted（）、update（）</p><ul><li>bind（）和update（）就是之前的函数写法，在第一次绑定的时候调用bind（），在模板更新重新解析的时候调用update（）</li><li>inserted（）在元素被放进页面时调用。<strong>有些方法需要先放进页面才能实现，例如查找父级元素，聚焦，都需要本身先在document中</strong></li></ul><h4 id="vue的生命周期" tabindex="-1"><a class="header-anchor" href="#vue的生命周期" aria-hidden="true">#</a> Vue的生命周期</h4><p>挂载步骤：</p><ul><li>未初始化阶段</li><li>初始化阶段，创建的内容是<strong>数据监测和数据代理</strong>而不是vm。这个阶段前会调用beforeCreate（），这个阶段后会调用created（）</li><li>（未挂载阶段）解析模板阶段，解析模板生成虚拟dom，但还没有真实dom，还没有挂载【第一次把内容放到页面上】内容到页面</li><li>挂载阶段，把<strong>虚拟dom转换为真实dom，把虚拟dom存起来【存到vm.$el属性】，并且把真实dom插入页面</strong>。这个阶段前会调用beforeMount（），这个阶段后会调用mounted（）</li></ul><p>更新步骤：</p><ul><li>页面未改变阶段，<strong>此时数据变了，但页面还是旧的</strong>。当数据变化就会开始这个阶段</li><li>把数据更改到页面阶段，重新解析模板生成新的虚拟dom并且拿旧的虚拟dom和新的虚拟dom作比较然后<strong>完成页面更新</strong>。这个阶段前会调用beforeUpdate（），这个阶段后会调用updated（）</li></ul><p>销毁步骤：</p><ul><li>准备销毁阶段，各种东西都还在。当实例准备销毁就会进入这个阶段，例如vm.$destroy（）指定vm去死，或者vm因为其他原因要销毁了</li><li>销毁阶段，销毁vm并清理与所有实例【组件】的连接，指令和自定义监听器全解绑。这个阶段前调用beforeDestroy（），这个阶段后调用destroyed（）</li></ul><p>总结：</p><p>主要就是4件大事：创建监测和代理，内容挂载到页面，数据更新到页面，销毁</p><p>这4件大事都分出了两个阶段，例如销毁就把时间轴分成了销毁前和销毁后两部分</p><p>常用：</p><ul><li>mounted（）</li><li>beforeDestroy（），<strong>不会在这里更新数据，因为就算更新完，下一步就是删除，所以更新也没用</strong></li></ul><p>理解：</p><p>要在钩子（也就是上面提到的函数）中写后续操作的原因：<strong>无论什么时候，什么原因，只要触发了钩子，都会做提前安排好的工作</strong></p><p>如果是自杀，张三能够自己决定什么时候死，所以可以先准备后事然后再完成死亡。但是很多时候是他杀。所以如果想无论怎么死都完成后事，就在beforeDestroy（）写如何处理后事。<strong>这样的话只要被发现你要死了，就一定会去操办后事</strong></p><h3 id="vue组件化编程" tabindex="-1"><a class="header-anchor" href="#vue组件化编程" aria-hidden="true">#</a> Vue组件化编程</h3><h4 id="为什么要组件化" tabindex="-1"><a class="header-anchor" href="#为什么要组件化" aria-hidden="true">#</a> 为什么要组件化</h4><ul><li>传统形式：html文件引js文件和css文件，依赖关系混乱不好维护。代码复用率低</li><li>组件化形式：组件文件是<strong>实现局部功能的</strong>代码的集合。包括了样式、结构、交互。组件可以包括组件，树形结构。<strong>组件最终归vm管理</strong></li></ul><h4 id="非单文件组件" tabindex="-1"><a class="header-anchor" href="#非单文件组件" aria-hidden="true">#</a> 非单文件组件</h4><p>创建：const xxx = Vue.extend（配置对象），简写为const xxx=配置对象</p><ul><li>组件一定不能写el配置项来选择服务于谁。<strong>组件都是被vm管理的，vm来决定内部的组件服务于哪个容器</strong></li><li>组件中的<strong>data一定要用函数</strong>。如果是用对象，每个复用这个组件的地方都会指向同一个对象，在a处修改，b处的也被修改了。<strong>用函数每次都是返回一个新的匿名对象，不会出现这种情况。</strong></li><li>组件的<strong>结构靠template（模组）来写</strong>，模组的内容<strong>只能有一个根节点</strong>。为了方便换行，用模板字符串的引号``</li><li>组件中可以用name属性来指定组件在开发者工具的名字</li></ul><p>局部注册：创建好xxx之后，在某个vm配置文件下写<strong>components对象</strong>，属性就是组件对象x：xxx</p><p>全局注册：创建好xxx之后，Vue.component（x，xxx）</p><p>使用：在容器里面直接用components里面的&lt;x&gt;&lt;/&gt;，或者&lt;x/&gt;（这种写法必须要在脚手架）</p><p>命名：</p><ul><li>MySchool（需要Vue脚手架支持）</li><li>my-school</li></ul><h5 id="组件的嵌套" tabindex="-1"><a class="header-anchor" href="#组件的嵌套" aria-hidden="true">#</a> 组件的嵌套</h5><p>组件内部也可以有components</p><p>如果有嵌套关系，就需要在定义的时候<strong>先定义儿子组件再定义父亲组件</strong>，否则父亲找不到儿子</p><p>父级<strong>只能用亲儿子级的组件</strong></p><p>实际开发中，Root下通常只会有一个儿子组件就是app，<strong>app组件一人之下万人之上</strong></p><h5 id="项目结构和template的转化" tabindex="-1"><a class="header-anchor" href="#项目结构和template的转化" aria-hidden="true">#</a> 项目结构和template的转化</h5><p>template的**第一个标签【包括标签本身和内部】**会被获取，并替换掉要替换的东西（容器，或者组件标签）</p><h5 id="vuecomponent构造函数" tabindex="-1"><a class="header-anchor" href="#vuecomponent构造函数" aria-hidden="true">#</a> VueComponent构造函数</h5><p>创建组件语句：const xxx = Vue.extend（对象），这个xxx是一个VueComponent构造函数</p><p>每个组件都是构造函数。<strong>不同构造函数构造出来的东西</strong>内容是不同的。例如app的构造出来是app，header构造出来的是header</p><p>构造函数的实例化，在<strong>用标签的时候</strong></p><p>可以理解为：你用一些配置信息【配置对象】写【调用Vue.extend（）】了一张图纸【VueComponent构造函数】，用它可以创建出很多实例</p><h5 id="vm和vc的内置关系" tabindex="-1"><a class="header-anchor" href="#vm和vc的内置关系" aria-hidden="true">#</a> vm和vc的内置关系</h5><p>vc的隐式原型链上会有Vue.prototype，也就是<strong>让组件实例能够使用Vue的属性和方法</strong></p><p>vc是VueComponent的实例，vc的隐式原型就是VueComponent.prototype。顺着隐式原型链的话，因为prototype是个对象，隐式原型链的下一步就是找Object，这样的话就用不了Vue原型对象的的属性和方法，所以就让<strong>VueComponent.prototype这个对象的隐式原型属性指向Vue.prototype，去用Vue原型中的方法</strong></p><h4 id="单文件组件" tabindex="-1"><a class="header-anchor" href="#单文件组件" aria-hidden="true">#</a> 单文件组件</h4><p>备注：浏览器不能识别vue文件，就像不能识别less，必须先变成css文件。需要通过webpack，或是用封装了webpack工具的<strong>脚手架</strong>，有了脚手架，浏览器就能认识vue文件了</p><p>组件包括三部分：</p><ul><li>script 交互</li><li>template 结构</li><li>style 样式</li></ul><p>main.js：</p><ul><li>每个vue文件都是一个组件。要用上这些组件还需要有vm，所以需要在一个js文件中，<strong>创建Vue实例，并且获取App.vue</strong>，并且指定template就是单app标签</li></ul><p>组件的暴露与引入：</p><ul><li><p>因为组件放在不同的文件中，需要引入组件，对应的就有暴露：</p><ul><li><p>暴露有默认、分别、统一。配合引入，<strong>用统一暴露，也就是export default</strong></p></li><li><p>引入有通用、解构赋值、简便【暴露时必须用统一暴露】</p></li></ul></li></ul><p>最终的html文件，需要引入vue，引入入口文件main.js【负责创建vm引用app】，并且<strong>有容器</strong></p><h5 id="scoped属性" tabindex="-1"><a class="header-anchor" href="#scoped属性" aria-hidden="true">#</a> scoped属性</h5><p>功能：让样式只作用于当前组件</p><p>使用：加在style标签上</p><h5 id="lang属性" tabindex="-1"><a class="header-anchor" href="#lang属性" aria-hidden="true">#</a> lang属性</h5><p>在style标签上使用，可以指定使用的语言是css还是less，使用less需要现在npm安装：npm i less-loader@7</p><h3 id="vue-cli脚手架" tabindex="-1"><a class="header-anchor" href="#vue-cli脚手架" aria-hidden="true">#</a> vue-cli脚手架</h3><h4 id="创建脚手架" tabindex="-1"><a class="header-anchor" href="#创建脚手架" aria-hidden="true">#</a> 创建脚手架</h4><p>在某个目录打开cmd，输入vue create 名字。然后进去那个文件，npm run serve就能运行</p><h4 id="脚手架结构" tabindex="-1"><a class="header-anchor" href="#脚手架结构" aria-hidden="true">#</a> 脚手架结构</h4><ul><li><p>外部</p><ul><li><p>git配置文件：配置哪些文件接收git管理</p></li><li><p>babel配置文件：如何把ES6变ES5</p></li><li><p>package包管理文件：包的说明书</p></li><li><p>readme说明：介绍文件</p></li></ul></li><li><p>src</p><ul><li>App.vue：一人之下万人之上的组件</li><li>main.js：<strong>入口文件</strong><ul><li>引入vue【这里的vue是轻便版的，<strong>少了模板解析器，所以不能解析template</strong>，所以只能依靠render，或者不引用残缺版的vue，引入完整版vue】</li><li>引入app.vue</li><li>创建vm</li><li>给vm选择容器</li><li>把app组件放到容器，通过<strong>属性render</strong><ul><li>render是个函数，参数是函数createElement。当render的返回值是调用createElement（）的结果就会在页面上添加标签</li><li>createElement（）的参数：如果是普通标签，就要写明白是什么标签，和标签体的内容。<strong>如果是组件，就直接用组件名</strong></li></ul></li></ul></li><li>assets：静态资源存放的目录</li><li>components：放组件的目录</li></ul></li><li><p>public</p><ul><li>index.html：那个最终的html</li></ul></li></ul><h4 id="修改配置文件" tabindex="-1"><a class="header-anchor" href="#修改配置文件" aria-hidden="true">#</a> 修改配置文件</h4><p>vue脚手架隐藏了webpack的配置，<strong>需要查看</strong>的话输入 vue inspect &gt; output.js，只是生成JSON格式的信息给你看，<strong>不能改</strong></p><p>不能改：</p><ul><li>public文件夹</li><li>图标文件</li><li>index.html文件</li><li>src文件夹</li><li>main.js</li></ul><p><strong>真要改的话，需要创建vue.config.js文件</strong>，写配置。最后会<strong>把这里的配置和webpack中的配置合并</strong>使用。可以在此处修改语法检查：lintOnSave：false</p><h4 id="ref属性" tabindex="-1"><a class="header-anchor" href="#ref属性" aria-hidden="true">#</a> ref属性</h4><p>ref用于替换标签中的id属性</p><p>配置了ref属性的会在vm/vc中的$refs中找得到，可通过this$refs.ref值获取</p><ul><li>ref用于普通标签，获取到真实dom</li><li>ref<strong>用于组件标签，获取到的是vc</strong></li></ul><h4 id="props配置项" tabindex="-1"><a class="header-anchor" href="#props配置项" aria-hidden="true">#</a> props配置项</h4><p>功能：用于接收<strong>从组件标签传入的数据</strong>。但是兄弟之间不能直接对话，只能和父亲沟通</p><p>特点：<strong>不能修改</strong>。如果要修改，只能是在data配置项中创建别的属性 = this.属性，然后修改data里的这个属性</p><p>配置：</p><ul><li>数组，props: [ &#39;name&#39;, &#39;age&#39;, &#39;sex&#39; ]</li><li>对象，props：{ name：String，age：Number，sex：String }，<strong>可以限定类型</strong></li><li>对象改：每个属性作为一个对象，对象内部包括属性 <ul><li>type指定类型</li><li>required指定是否必填</li><li>default指定默认值</li></ul></li></ul><h4 id="配置项-混合mixin" tabindex="-1"><a class="header-anchor" href="#配置项-混合mixin" aria-hidden="true">#</a> 配置项：混合mixin</h4><p>当<strong>组件之间有相同的代码，可以把相同部分写在外边</strong>，并且暴露。在js里面引用即可，最好是<strong>用解构赋值引用</strong></p><p>写法：mixins：[混合1，混合2]，<strong>暴露的混合是个对象</strong>，所以引用的其实也是对象</p><p>特点：如果有重复的部分，会以自己写的为主。例如data中有x是100，混合中data的x是200，那么会是100</p><p>局部配置是在内部写配置项，全局配置是在vm那边。也是先引入，然后混合Vue.mixin（xxx）</p><h4 id="插件" tabindex="-1"><a class="header-anchor" href="#插件" aria-hidden="true">#</a> 插件</h4><p>功能：操作Vue</p><p>操作：创建一个模块，暴露一个对象，这个对象内部有方法install（）。第一参数是Vue。所有全局配置用到Vue的都可以在这里用</p><p>引入：在main.js引入这个模块，然后Vue.use（引入的对象）</p><h4 id="浏览器本地存储" tabindex="-1"><a class="header-anchor" href="#浏览器本地存储" aria-hidden="true">#</a> 浏览器本地存储</h4><p>这是window中的属性</p><ul><li>localStorage <ul><li>getItem，参数是键值对，<strong>两个都是字符串</strong>。如果要存对象，靠JSON.stringify和parse来把对象转为格式化字符串</li><li>setItem</li><li>removeItem</li><li>claer</li></ul></li><li>sessionStorage，和localStorage的区别是只存在于浏览器打开期间</li></ul><h4 id="todo-list案例讲解编码流程" tabindex="-1"><a class="header-anchor" href="#todo-list案例讲解编码流程" aria-hidden="true">#</a> Todo-list案例讲解编码流程</h4><p>步骤：</p><ul><li><p>实现静态组件，抽取组件</p></li><li><p>实现动态数据</p><ul><li><p>数据存放在哪：如果多个组件都要用，<strong>就放到他们共同的祖先【状态提升】</strong></p></li><li><p>数据的传递，最原始的方法兄弟间不能传递，就依靠父亲组件来传递。<strong>缺点：要跨越多层原本不需要接收数据的</strong></p><ul><li>父给子传数据非常简单，子组件通过props就能接受</li><li>父组件可以把函数传给子组件，也就是让<strong>子组件有个属性也指向那个函数</strong>，然后传入子属性的参数调用。<strong>定义在父级的元素获取子级的属性</strong></li></ul></li><li><p>props里的数据不要动，<strong>要动就在父亲动</strong>，直接把方法传给儿子，儿子调用父亲的方法来操作数据。或者是列表项传给item了可以改</p></li><li><p>数据存储：监视列表，当列表变化的时候就<strong>重新把整个列表存到localStorage中</strong>。并且需要<strong>开启深度监视</strong>，也就是对象内部的值变也会知道</p></li></ul></li><li><p>交互</p></li></ul><p>注意事项</p><ul><li>传递数据主要靠全局事件总线，如果是父子可以用自定义事件</li><li>数据在哪，操作数据的方法就写在哪</li><li><strong>mounted给全局数据总线绑定事件，最好在beforeDestroy写解绑</strong></li><li>数据存到localStorage里面，通过watch对数据进行监听，并且要深度监听</li><li>动态添加属性不要直接给vc身上放，放出来的是没有响应式的数据。要添加就用$set（）来加。后续再用倒是不用，因为已经数据代理到vc上了</li><li>常用功能： <ul><li>设置输入框内容：【：value】</li><li>选择性展示：v-show，封装的是display</li><li>$nextTick方法，参数是一个函数。在页面更新结束后再调用，也就是这回调函数最后执行。<strong>常用于聚焦这种会有新的dom出现的时候</strong></li></ul></li></ul><h4 id="vue组件的自定义事件" tabindex="-1"><a class="header-anchor" href="#vue组件的自定义事件" aria-hidden="true">#</a> Vue组件的自定义事件</h4><p>理解：</p><ul><li><p>事件就是当触发某种操作，就会触发指定回调。例如click就是做了点击这个操作，就会触发指定回调</p></li><li><p><strong>自定义事件是给组件的。对某个元素进行操作后</strong>，会触发指定回调。例如点击了某个普通的DOM对象，这个对象有@click，在这个@click触发的回调函数体内执行了：this.$on（‘自定义事件’ [ ，参数1，参数2……]），意思是回调的操作就是触发那个事件。也就是说，【对某个特定的元素操作】后就要让浏览器认为你【触发了这个事件】，也就是说，<strong>你要让浏览器认为【对某个特定的元素操作】就是【这个自定义事件】</strong></p></li></ul><p>传参：</p><ul><li>旧方法：父级给子级传递方法，子级调用方法向父级传参，父级传递给子级的方法中可以获取到参数</li><li>自定义事件：父级给子级传递方法【自定义事件】，子级调用方法【执行自定义事件】向父级传参，父级的自定义【事件触发的回调】可以获取到参数。参数的接收可以用【扩展运算符。。。args】 <ul><li>区别：<strong>旧方法子集必须通过props接收父级的方法，自定义事件不需要接收到props</strong></li><li>优化：可以不直接写@xxx = &quot;fun&quot;，可以给标签添加属性ref，然后通过this.$refs.ref值获取到vc实例，然后调用vc.$on（&#39;xxx&#39;，回调）。也就是<strong>不直接绑定，而是灵活的绑定自定义事件</strong></li></ul></li></ul><p>绑定：</p><ul><li>父级：给子级绑定事件与回调。在子级的组件标签中@xxx = &quot;fun&quot;或者在需要的时候子级.$on（‘xxx’，fun）</li><li>子级：调用emit触发事件。在某个操作的回调中写<strong>this.$emit（&#39;xxx&#39;，参数）</strong></li></ul><p>解绑：</p><ul><li>解绑： <ul><li>销毁全部：this.$off（）</li><li>销毁一个：this.$off（‘xxx’）</li><li>销毁多个：this.$off（[ &#39;xxx&#39; , &#39;yyy&#39; ]）</li></ul></li><li>销毁组件，引起自定义事件失效</li></ul><p>组件使用原生事件：</p><p>如果在组件写@click=“fun”，Vue解析会默认把click当作自定义事件。如果想用原生就要写成@click.native</p><p>在todo-list案例中修改传递数据的方式：</p><ul><li><p>不需要传参数了，把标签中原本传参语句:xxx=&quot;xxx&quot;改成@xxx=“xxx”，也就是<strong>给组件添加xxx事件和回调</strong></p></li><li><p>子组件中<strong>不需要props</strong>中获取父级传过来的xxx了，删掉</p></li><li><p>组件内部，以前是调用原本传过来的方法来传参数。改成this.$emit，<strong>触发自定义事件，从而让外部的回调执行</strong></p></li><li><p>如果有需要传递的，同理传递</p><p>内层组件item内部的script中，一个方法调用this.$emit（‘xxx’），让中间层item标签的xxx事件触发。事件触发后，会执行在main写好的的回调，并获参数。main的回调中，调用this.$emit（‘xxx’），让外层main标签的xxx事件触发。main组件的xxx事件触发，事件触发后，会执行在app写好的的回调，并获取参数</p></li></ul><h4 id="全局事件总线" tabindex="-1"><a class="header-anchor" href="#全局事件总线" aria-hidden="true">#</a> 全局事件总线</h4><p>功能：任意组件之间的数据传递</p><p>原理：依靠自定义事件传递数据。提供一个独立于所有组件的东西x，能让<strong>所有组件都用它</strong>，用x的时候往x添加自定义事件指定回调。在<strong>x内部可以调用$emit</strong>方法，让自定义事件触发</p><p>理解：有ab组件，b和a都能用x。a组件中使用x组件，给x组件添加事件xx指定回调aa（），<strong>当xx触发，a就会调用aa（）</strong>。b用x来调用this.$emit（‘xx’）<strong>让xx触发并传递b的参数</strong></p><p>实现：先找个a和b组件都有的地方，添加一个x，这个x选取Vue的原型上存放最合适，所有vc都能在原型链上找到它，而这个x就是vm。因为<strong>是同一个x，所以定义的自定义事件不能重复</strong>，并且当某个组件<strong>不用的时候，需要把自定义事件解绑，否则浪费名字</strong></p><ul><li><p>接收方：负责绑定事件与回调</p><p>mounted(){</p><p>​ this.x.$on(&#39;hello&#39;,this.doHello)</p><p>}</p></li><li><p>发送方：负责触发事件，传递参数</p><p>methods:{</p><p>​ send(){</p><p>​ this.x.$emit(&#39;hello&#39;,this.name)</p><p>​ }</p><p>}</p><p>然后找个事件触发send（）</p></li></ul><h4 id="消息订阅与发布" tabindex="-1"><a class="header-anchor" href="#消息订阅与发布" aria-hidden="true">#</a> 消息订阅与发布</h4><p>引入库：npm i pubsub-js</p><p>原理：<strong>相当于订报纸</strong></p><ul><li>接收方订阅消息demo，说明住址。fun：pubsub.subscribe（&#39;xxx&#39;，this.fun）</li><li>发送方发送消息可以很多，当发送的消息是demo，携带的数据就会给到fun。pubsub.publish（‘xxx’，数据）</li></ul><p>使用：</p><ul><li>接受方订阅这些初始化操作，在mounted（）中进行</li><li>在beforeDestroyed（）中pubsub.unsubscribe（&#39;xxx&#39;）取消订阅</li></ul><h4 id="过渡与动画" tabindex="-1"><a class="header-anchor" href="#过渡与动画" aria-hidden="true">#</a> 过渡与动画</h4><p><strong>使用transition标签</strong>，可以为transition内部的标签添加过渡与动画。当内部标签插入、更新、移除时<strong>添加类来添加样式</strong></p><p>如果内部有多个标签，需要用transition-group，<strong>并且给内部标签加上key属性</strong></p><p>transition有的类：<strong>如果transition的name属性是hello</strong></p><ul><li>hello-enter, hello-leave-to，在进入的起点/退出的终点时添加的类</li><li>hello-enter-active, hello-leave-active，指定在起点终点中间时添加的类</li><li>hello-enter-to，hello-leave，指定在进入的终点/退出时添加的类</li></ul><p><strong>用动画写只需要设定起点终点之间的类的样式</strong>，因为动画肯定要写0%和100%，就相当于过渡写了开头结尾</p><p>过渡需要设置三种的样式</p><h4 id="插槽" tabindex="-1"><a class="header-anchor" href="#插槽" aria-hidden="true">#</a> 插槽</h4><p>功能：<strong>在Vue组件标签内部放入内容</strong>，就需要在Vue组件内部写好slot，用的时候就会对应上去</p><p>特点：如果没有在Vue组件内部用东西的话，会显示slot标签体的内容</p><p>具名插槽：如果要有多个插槽，可以给插槽命名，slot标签加上name属性。在<strong>用到插槽的标签中加入属性slot指定name</strong>。<strong>如果用tempalte</strong>把内容包起来，可以通过v-slot属性指定name</p><p>作用域插槽：</p><ul><li>如果app用a组件，<strong>数据放在app中</strong>，当用a且要给插槽放东西，就需要给a设置结构和数据</li><li>如果app用a组件，<strong>数据放在a中</strong>，当用a且要给插槽放东西，需要给a设置结构，<strong>数据在a中而不是app中，需要获取这个数据来用</strong><ul><li>a传递数据：在slot标签中像父子传数据一样传送</li><li>app接收数据：在对应插槽的地方<strong>加上template包住</strong>，用scope属性获取数据对象</li></ul></li></ul><h3 id="vue中的ajax" tabindex="-1"><a class="header-anchor" href="#vue中的ajax" aria-hidden="true">#</a> Vue中的AJAX</h3><p>AJAX可选择方式：</p><ul><li>xhr：new、open、send、条件判断。可惜是太老</li><li>jQuery：封装了AJAX请求。但基本是为了DOM操作</li><li>axios：主流</li><li>fetch：和xhr平级</li></ul><p>AJAX异步问题的解决：</p><ul><li>CORS：在后端对响应头进行设置。需要麻烦后端，不进行过滤不安全</li><li>JSONP：利用script标签的可跨域特性。只能用于get</li><li>代理服务器：例如nginx，或者vue-cli脚手架提供的办法，在vue.config.js文件中写配置，<strong>每次修改需要重新启动服务</strong></li></ul><p>配置语句：</p><ul><li><p>第一种：</p><p>module.exports = { devServer:{ proxy:&#39;http://localhost:3000&#39; } } 问题：</p><ul><li><strong>不能自由选择是否路由</strong>。如果public目录下有访问的资源，就不会再去目标服务器而是直接返回public目录下的资源</li><li>不能配置多个路由，这个代理服务器只能访问proxy代理的地址</li></ul></li><li><p>第二种：</p><p>module.exports = { devServer:{ proxy:{ &#39;/student&#39;:{ target:&#39;http://localhost:3000&#39;, pathRewrite:{&#39;^/student&#39;:&#39;&#39;}, ws:true, changeOrigin:true } } } } 解决了配置方法1的问题：</p><ul><li>能够选择是否路由：上方代码的意思是：当<strong>请求资源的地址的端口号后方出现&#39;/student&#39;</strong>，就去访问target属性地址的服务器，并且把请求的资源地址中用于标记的&#39;/student&#39;换为空</li><li>能够配置多个路由</li></ul></li></ul><h3 id="vuex保存数据" tabindex="-1"><a class="header-anchor" href="#vuex保存数据" aria-hidden="true">#</a> vuex保存数据</h3><p>理解vuex：</p><ul><li><p>vuex是集中式状态（数据）管理的Vue插件，负责对数据实现读写，适用于任何<strong>组件之间的通信</strong></p></li><li><p>可以理解为vuex是一个<strong>存放数据的地方</strong>，里面的数据是全局<strong>共享</strong>的，只有一份，大家都能看到</p></li><li><p>和普通存储数据的区别：普通的数据往往是在哪用就放在哪，数据一变导致重新解析模板</p></li></ul><p>工作流程：</p><ul><li>state是个对象，负责<strong>存放数据</strong>。调用**render（）**把存的数据给到vc用</li><li>vc是<strong>vc</strong>。vc调用**dispatch（）**方法传递操作和参数给actions来操作数据</li><li>actions是个对象，<strong>存放操作与对应的回调</strong>。actions收到传递过来的操作和参数，找回调并执行。actions调用**commit（）**把操作和参数传给mutations <ul><li>这一步有点多余，<strong>完全可以从vc调用commit（）把操作和参数直接传给mutations</strong></li><li>actions的功能还有：当数据需要AJAX请求才能获取，就在这里发送AJAX请求。如果需要获取数据，就还是走这一步</li></ul></li><li>mutations是个对象，<strong>负责处理数据</strong>。mutations获取到参数和操作，找到对应的回调，调用**mutate（）**根据原本state和新数据修改，修改后数据给state</li></ul><p>流程补充：</p><ul><li>vuex包括的state、actions、mutations都是对象</li><li>三个对象事实上都需要受到store对象的控制，因为dispatch、commit这些方法都是属于store的。<strong>要让所有vm、vc都能看到store</strong>，通过Vue的配置项</li><li>流程可以理解为：菜、顾客，服务员、厨师</li></ul><p>代码流程：</p><ul><li><p>搭建环境：</p><ul><li>npm i vuex@3</li><li>创建store.js，<strong>创建并暴露store对象</strong>，属性是state、actions、mutations。创建store的<strong>构造函数是Vuex.Store，所以还需要引入Vuex</strong></li><li>在main.js引入store，Vue实例中写store：store</li></ul></li><li><p>编写流程：</p><ul><li>如果需要修改数据，就<strong>用this.$store调用dispatch，传入操作类型和数值给actions</strong></li><li>actions中配置操作类型和对应的回调。回调的参数有：context上下文对象【将复杂的对象简化为满足当前环境需要的对象，只有原来的部分属性但是在当前的环境下够用了】，dispatch传过来的参数。<strong>回调的内容要用context来调用commit</strong></li><li>在mutations里面也是配置操作类型和回调。<strong>回调的参数有state和新数据</strong>，操作数据即可</li><li><strong>可以跳过actions</strong>，直接调用this.$store.commit（）</li></ul></li><li><p>$store.getters属性，也是个对象</p><ul><li><strong>数据需要用state来计算</strong>，就在getter写，像computed里面写</li><li>每个数据写成一个方法，因为需要用state计算，所以每个方法的<strong>参数都是state</strong></li><li>用的时候也是$store.getter.xxx就行</li></ul></li><li><p>代码简化：</p><p>用vuex，会在模板中<strong>大量使用this.$store.state.xxx</strong>、getters.xxx、commit（）、dispatch（），代码不够精简</p><p>为了精简可以在computed下创建变量 student= this.$store.state.student，但重复书写创建变量也不够精简</p><p>commit（）通常也会放到函数中封装使用</p><p>vuex提供了几个方法，封装了创建变量功能和封装函数功能【封装的函数参数自动包括value】，<strong>要从vuex引入</strong></p><ul><li><p>mapState：传入参数为对象，<strong>键值对是本地名字和state下的名字</strong>，写成同名可以省事，全部写成同名参数就能用数组</p></li><li><p>mapGetter：同上</p></li><li><p>mapMutation：创建调用commit（）的方法例如add（）。<strong>mapMutation（）传入参数为对象，键值对是方法名字和操作类型</strong>。用mapMutation创建的方法，都会有参数value</p></li><li><p>mapAction：创建调用dispatch（）的方法</p><p>computed:{ // sum(){ // return this.$store.state.sum // }, ...mapState([&#39;sum&#39;]), ...mapGetters([&#39;bigSum&#39;]), }, methods: { // add() { // this.$store.dispatch(&#39;jia&#39;,this.n) // }, ...mapActions({add:&#39;jia&#39;}) },</p></li></ul></li><li><p>模块化</p><ul><li><p>在store的index.js中创建多个对象，每个对象封装state、getters、actions、mutations</p></li><li><p>也可以直接创建多个js模块，把对象暴露，index来引入</p></li><li><p>如果store包含多个对象，对象再包含state这些，在用mapState的时候，存储上就不是store.state.xxx了，而是store.yyy.state.xxx。实际上用的是store.state.yyy.xxx。但是这样的话也麻烦，每次都要yyy。<strong>mapState方法可以让参数</strong>变成：</p><ul><li>第一个参数，yyy，指定从store的哪个模块</li><li>第二个参数，xxx，指定读取哪些数据</li></ul></li><li><p><strong>需要在模块中添加属性namespaced：true，才能用mapState这样获取数据</strong>，才能让分类名被mapState认识</p></li><li><p>如果不是用mapState，而是<strong>直接调用</strong></p><ul><li>state、getters：this.$store.state**.yyy.xxx**</li><li>commit、dispatch：原本是this.$store.commit（‘类型’，参数），<strong>改成this.$store.commit（‘yyy/类型’，参数）</strong></li></ul></li></ul></li></ul><h3 id="vue-router前端路由" tabindex="-1"><a class="header-anchor" href="#vue-router前端路由" aria-hidden="true">#</a> vue-router前端路由</h3><h4 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h4><p>路由：key-value，一组匹配的端口和主机</p><p>路由器：组织管理多个路由</p><p>vue-router：一个插件库。网页的路由器，管理的<strong>路由是匹配的页面的内容和网址栏的变化</strong>，实现SPA（single page application）。因为是单页，请求不同内容只会局部更新，所以都是AJAX请求</p><h4 id="基本路由" tabindex="-1"><a class="header-anchor" href="#基本路由" aria-hidden="true">#</a> 基本路由</h4><ul><li>下载：npm i vue-router@3</li><li>引入：import、use、在Vue对象中设置<strong>属性router</strong>，也就是路由器</li><li>创建路由器：创建router.js，引入router，引入会用到的组件。暴露对象，对象内配置<strong>属性routes路由</strong>：[]，每个路由是个对象，包括component和path</li><li>使用： <ul><li>在app.vue<strong>写不变的布局</strong></li><li>在app.vue内用<strong>router-link标签实现路由的切换</strong>。<strong>router-link会被解析成a标签</strong><ul><li>如果要设置选中的样式，<strong>用active-class属性</strong></li><li>如果要设置目标，用to属性，to属性的地址是路由配置的地址</li></ul></li><li><strong>router-view</strong>指定路由内容展示的地方</li></ul></li><li>优化：为了区分普通组件和路由组件【没有直接用那个标签】，新建<strong>文件夹pages存放路由组件</strong></li></ul><h4 id="嵌套路由" tabindex="-1"><a class="header-anchor" href="#嵌套路由" aria-hidden="true">#</a> 嵌套路由</h4><p>在一级路由下面，像写一级路由一样写一个数组，内部多个对象，属性有component和path</p><ul><li><p>多级路由的属性名不是routes，<strong>而是children</strong></p></li><li><p><strong>children的path不用斜杠</strong>，直接名字</p></li><li><p>用多级路由跳转的时候to属性要写**/父级/子级**</p></li></ul><h5 id="命名路由优化" tabindex="-1"><a class="header-anchor" href="#命名路由优化" aria-hidden="true">#</a> 命名路由优化</h5><p>因为嵌套路由嵌套得多了，path会变得太长，如果在路由配置中有name属性，<strong>就能直接在用的时候用name来指定</strong>，不用写path而是name。<strong>但是必须要用对象写法</strong>，用字符串写法name会被解析成地址</p><h4 id="路由传参" tabindex="-1"><a class="header-anchor" href="#路由传参" aria-hidden="true">#</a> 路由传参</h4><p>传参场景：渲染页面，例如点击列表跳转到商品详情页面，<strong>100个商品不可能写100个页面</strong>逐一匹配。只需要写一个页面，每次<strong>渲染页面的时候传入参数</strong></p><p>query：</p><ul><li><p>在to中发送用query格式：</p><ul><li><p>to用字符串格式：/home/news?xxx=yyy&amp;aaa=bbb</p><p>参数多了容易看不懂。而且需要注意因为要传参数所以需要用到v-bind，而v-bind不能解析地址，所以要<strong>配合模板字符串使用</strong></p></li><li><p>to用对象格式：两个属性，一个是字符串path，一个是对象query，包括各种参数</p></li></ul></li><li><p>组件获取数据：this.$route.query获取</p></li></ul><p>params：</p><ul><li>在to中发送用params格式： <ul><li>字符串格式：/home/news/yyy/bbb</li><li>对象格式：只能用命名路由，不能用path，只能用name</li></ul></li><li><strong>需要在route里面配置</strong>path的格式：<strong>使用占位符知名参数</strong>，例如：news/：xxx/：aaa</li><li>获取数据：this.$route.params获取</li></ul><p>props：</p><ul><li><p>作用：获取参数需要this.$route.params、this.$route.query，太长了，如果用计算属性也很麻烦，就<strong>用props来实现</strong></p></li><li><p>配置props：</p><ul><li>props值为对象，内部的key-value会通过props传给组件</li><li>props值为bool，会<strong>把params参数</strong>通过props传给组件</li><li>props值为函数，<strong>函数参数有$route</strong>，所以可以调用$route.query获取query参数，返回一个对象给组件</li></ul></li><li><p>发送：无影响</p></li><li><p>接收：不是在router-view里面接收，而是在vc里面的props属性接收</p></li></ul><h4 id="跳转模式" tabindex="-1"><a class="header-anchor" href="#跳转模式" aria-hidden="true">#</a> 跳转模式</h4><p>router-link的属性</p><ul><li><p>replace：点击并不是压栈，而是<strong>替换栈顶</strong>，浏览器没得后退。不管是不是父级、同级，直接替换掉栈顶</p></li><li><p>push：点击压栈，默认的模式</p></li></ul><h4 id="编程式路由导航" tabindex="-1"><a class="header-anchor" href="#编程式路由导航" aria-hidden="true">#</a> 编程式路由导航</h4><p>定义：不借助router-link的路由导航</p><p>功能：因为router-link是a标签，不能用于其他，所以就要用这种方式，可以给所有标签绑定事件，在<strong>事件回调中实现路由跳转</strong></p><p>操作：route配置项是每个vc独有的，而router路由器是在vm的，只有一个，通过vm.$router的api来进行跳转等操作</p><ul><li>push（），参数是对象，包括路径和参数，也就是router-link的to参数</li><li>replace（），同理</li><li>go（），参数是数字，可前进可后退</li><li>forward（），1步</li><li>back（）</li></ul><h4 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h4><p>原因：当切走了之后，没看见的部分<strong>是被销毁了</strong>，不是display:none，所以需要缓存</p><p>操作：在需要缓存的内容，也就是router-view<strong>外部加上keep-alive标签</strong>，就能缓存</p><ul><li>默认是缓存内部所有内容</li><li>一个导航栏可以有很多项，例如home有news和message，如果只需要News缓存，<strong>设置属性include</strong>=”News“，这个News是组件名</li><li>如果要缓存多个，：include**=”[ &#39;News&#39;, &#39;Messages&#39; ]“</li></ul><h4 id="新钩子" tabindex="-1"><a class="header-anchor" href="#新钩子" aria-hidden="true">#</a> 新钩子</h4><p>如果又要缓存，不想让它销毁，但是又有定时器之类，关闭定时器在beforeDestroy钩子中，就比较麻烦。有新钩子</p><ul><li>activated（），看见的时候调用</li><li>deactivated（），看不见的时候调用。<strong>关闭定时器就可以写在这里</strong></li></ul><h4 id="路由守卫" tabindex="-1"><a class="header-anchor" href="#路由守卫" aria-hidden="true">#</a> 路由守卫</h4><ul><li><p>全局前置路由守卫beforeEach（）：</p><ul><li>全局：给index.js里面对暴露的对象router配置，配置的方法包括Each（）</li><li>前置：配置的方法包括before（），也就是跳转到某个页面前前会执行这个函数</li><li>参数：参数是一个函数，函数的参数有from、to、next。from和to都是route配置项，next是个函数，<strong>调用了next（）才能放行</strong></li><li>用处：<strong>权限检查</strong>，如果某个值不对，就不能看</li></ul></li><li><p>全局后置路由守卫afterEach（）</p><ul><li>后置：跳转到这个页面后会执行这个函数</li><li>参数：参数是一个函数，函数的参数有from、to</li><li>用处：<strong>做一些跳转成功后的操作</strong>，如果没跳转成功，自然也不会做</li></ul></li><li><p>独享路由守卫beforeEnter（），在<strong>route配置项内部，只有前置</strong></p></li><li><p>组件内路由守卫</p><ul><li><p>区别：跳转到一个路由的地址，全局的前置和后置路由守卫都是会调用的，而这里的不是，这和前后没关系，只和组件本身有关</p></li><li><p>函数：</p><ul><li><p>beforeRouteEnter（）：进入该组件时调用</p></li><li><p>beforeRouteLeave（）：退出该组件时调用</p></li></ul></li></ul></li></ul><h4 id="工作模式mode" tabindex="-1"><a class="header-anchor" href="#工作模式mode" aria-hidden="true">#</a> 工作模式mode</h4><p>在router里面配置mode属性</p><ul><li>history：/，兼容性差一点</li><li>hash：/#/，并且**/#/和后面的东西都不会传给服务器**</li></ul><h2 id="vue-3" tabindex="-1"><a class="header-anchor" href="#vue-3" aria-hidden="true">#</a> Vue 3</h2><h3 id="和vue2的区别" tabindex="-1"><a class="header-anchor" href="#和vue2的区别" aria-hidden="true">#</a> 和Vue2的区别</h3><p>性能提升</p><p>源码升级：Proxy代替了defineProperty、重写虚拟DOM的实现和Tree Shaking</p><p>配合TypeScript使用</p><p>新特性：</p><ul><li>Composition API</li><li>新的内置组件</li><li>新的生命周期钩子</li><li>其他</li></ul><h3 id="创建vue3工程" tabindex="-1"><a class="header-anchor" href="#创建vue3工程" aria-hidden="true">#</a> 创建Vue3工程</h3><ul><li>vue-cli：vue create 名字</li><li>vite：和webpack的区别是构建快。webpack是所有东西打包好后才说服务准备好了，而vite是一开始就说服务准备好了，对路由和模块动态引入，代码分割，要什么再给什么，按需编译。无需打包。快速热重载 <ul><li>npm init vite-app 名字</li><li>npm i，下载依赖</li><li>npm run dev，启动</li></ul></li></ul><h3 id="vue3工程结构" tabindex="-1"><a class="header-anchor" href="#vue3工程结构" aria-hidden="true">#</a> Vue3工程结构</h3><p>变化不大，基本就<strong>变了个 入口文件main.js</strong></p><p>不再是引入Vue构造函数然后创建实例vm，再把vm挂载到#app容器中</p><p>而是从vue<strong>引入{ createApp }方法</strong>，然后调用这个方法创建app，再把app挂载到#app容器中</p><p>这个app<strong>就像是以前的vm</strong>，管理App和以下的内容。和vm比，app更轻</p><p>每个组件的template中，不再限制一个元素</p><h3 id="常用composition-api" tabindex="-1"><a class="header-anchor" href="#常用composition-api" aria-hidden="true">#</a> 常用Composition API</h3><p>所谓组合API，都是函数</p><h4 id="setup" tabindex="-1"><a class="header-anchor" href="#setup" aria-hidden="true">#</a> setup</h4><ul><li>setup是个配置项，<strong>值是一个函数</strong>，<strong>通常是返回一个对象</strong></li><li>配置项如data、methods全部都要配置在setup内部</li><li>setup返回的对象中，<strong>需要包括setup中的属性和方法，才能在模板中使用</strong></li><li>setup不要和vue2的配置项混用，setup看不到外边的东西</li></ul><p>执行时机：在beforeCreate（）之前</p><p>参数：</p><ul><li>props：组件内部用props配置项接受了的传过来的属性</li><li>context：上下文对象 <ul><li>attrs：组件内部没有用props接收但是传过去来的属性</li><li>slots：组件收到传过来的的插槽内容</li><li>emit：组件收到的定义的自定义事件</li></ul></li></ul><h4 id="ref函数" tabindex="-1"><a class="header-anchor" href="#ref函数" aria-hidden="true">#</a> ref函数</h4><p>引入：从vue引入{ref}</p><p>功能：得到<strong>响应式的数据</strong>。响应式的数据不是ref（&quot;xxx&quot;）生成的RefImpl对象，<strong>而是ref（&quot;xxx&quot;）.value这个属性</strong></p><p>数据的使用：操作数据需要.value，模板中不需要.value</p><p>参数：</p><ul><li>基本数据类型：生成<strong>RefImpl类对象</strong>，ref（&quot;xxx&quot;）.value是响应式数据</li><li>对象：生成<strong>RefImpl类对象</strong>，value是一个Proxy类对象，这个对象的属性都是响应式数据。这个Proxy类对象是求助Vue3新函数reactive（）生成的</li></ul><p>响应式原理：Object.defineProperty</p><h4 id="reactive函数" tabindex="-1"><a class="header-anchor" href="#reactive函数" aria-hidden="true">#</a> reactive函数</h4><p>引入：从vue引入{reactive}</p><p>功能：得到<strong>响应式的数据</strong>，响应式的数据不是reactive（”xxx“），而是reactive（”xxx“）内部的属性</p><p>数据的使用：不需要.value</p><p>参数：只能传入对象或者函数，不能传入基本类型</p><ul><li>对象：得到Proxy对象，属性是响应式的</li><li>数组：得到Proxy对象 <ul><li><strong>可以直接通过数组下标赋值</strong></li><li><strong>可以直接添加、删除数据</strong></li></ul></li></ul><p>响应式原理：Proxy</p><h4 id="响应式原理" tabindex="-1"><a class="header-anchor" href="#响应式原理" aria-hidden="true">#</a> 响应式原理</h4><p>Vue2原理：defineProperty（）</p><ul><li>通过defineProperty（）进行数据代理，<strong>能够监测属性的get和set</strong>。当对象的属性变化，setter捕获，就会去修改data中的数据，data改变就会重新解析模板生成虚拟DOM对比更新模板。这样一来数据就是响应式的：修改数据页面中发生变化</li><li>但defineProperty（）这种方式有问题，但是有其他解决方式 <ul><li>只通过defineProperty<strong>不能监测属性的添加和删除</strong>。给对象添加的属性不是响应式的，没有getter和setter。给对象删除属性，这个对象是监测不到的。需要通过$set和$delete来解决</li><li>数组下标没有getter和setter，<strong>不能通过数组下标操作数据</strong>，也要通过$set解决的</li></ul></li></ul><p>Vue3原理：Proxy + Reflect</p><ul><li>通过Proxy捕获属性的变化，const d = Proxy（data，{}）。就算{}为空对象，也会有默认的getter和setter，但还是要自定义捕获后的操作 <ul><li>get（data，prop），获取时调用。<strong>参数是被代理的对象，和捕获到变化的属性</strong></li><li>set（data，prop，value），<strong>设置和添加时调用</strong></li><li>deleteProperty（data，prop），删除时调用</li></ul></li><li>通过Reflect对被代理对象进行操作 <ul><li>Reflect.get（data，prop）</li><li>Reflect.set（data，prop，value）</li><li>Reflect.deleteProperty（data，prop）</li></ul></li></ul><h4 id="computed函数" tabindex="-1"><a class="header-anchor" href="#computed函数" aria-hidden="true">#</a> computed函数</h4><p><strong>computed是个函数</strong>，参数可以是函数或者对象，利用computed（）<strong>创建变量</strong></p><ul><li>函数：这个函数代表getter，需要返回计算结果</li><li>对象：对象封装getter和setter两个函数，getter需要返回计算结果</li></ul><h4 id="watch函数" tabindex="-1"><a class="header-anchor" href="#watch函数" aria-hidden="true">#</a> watch函数</h4><p><strong>watch是个函数</strong>，参数有监视对象、监视操作、其他配置。操作可以是函数或者对象。watch（）没有返回值，它只是一个动作。<strong>watch（）可以多次调用</strong></p><p>用watch监视ref定义的数据、reactive定义的数据：</p><ul><li><p>监视ref定义的数据</p><ul><li>单个数据：watch（监视对象，监视操作，其他配置项对象【包括immediate和deep】）</li><li>多个数据：把<strong>监视对象写成数组</strong></li></ul></li><li><p>监视<strong>reactive定义的对象</strong></p><ul><li>获取oldValue无法正确获取</li><li>强制开启深度监视</li></ul></li><li><p>监视reactive定义的对象的普通属性</p><ul><li>监视属性不能直接写，需要写一个函数返回监视的属性</li><li>如果有多个，把监视对象写成数组，<strong>是写成多个函数，而不是返回值是数组</strong></li></ul></li><li><p>监视reactive定义的<strong>对象的对象属性</strong></p><ul><li>如果需要深度监视，需要开启</li></ul></li></ul><p>深度监视：</p><ul><li><p>reactive（）定义的Proxy对象可以深度监视</p></li><li><p>ref（）传入对象生成的RefImpl对象的value是Proxy对象。监视<strong>RefImpl对象，默认不能深度监视</strong></p><ul><li>可以靠watch（）的第三个参数设置deep：true</li><li>可以让watch（）的不是RefImpl，而是RefImpl.value，这个value是Proxy，由reactive定义，可以深度监视</li></ul></li></ul><h4 id="watcheffect函数" tabindex="-1"><a class="header-anchor" href="#watcheffect函数" aria-hidden="true">#</a> watchEffect函数</h4><p>使用：watchEffect（ () =&gt;{ }）</p><p>功能：watch的强化版，不需要指定监视的是谁。<strong>回调中用到了谁，就会监视谁</strong>。用到的内容发生改变，就会调用回调</p><p>配置：</p><ul><li>默认immediate</li><li>不能配置deep，不能深度监视</li></ul><h4 id="生命周期函数" tabindex="-1"><a class="header-anchor" href="#生命周期函数" aria-hidden="true">#</a> 生命周期函数</h4><p>初始化之前需要创建好app并且app找到容器挂载。之前的不需要挂载好，先创建vm和数据代理数据监视，如果没有容器就卡住，操作就白费了</p><p>destroy系列变成了unmounted系列</p><p>生命周期钩子可以作为配置项来写，也可以放进setup（）作为组合API。<strong>setup（）中的生命周期钩子没有create系列，其他系列在前面加on</strong></p><h4 id="自定义hook函数" tabindex="-1"><a class="header-anchor" href="#自定义hook函数" aria-hidden="true">#</a> 自定义hook函数</h4><p>配置：对setup函数中使用的composition API封装。暴露一个函数，内部可以封装ref（）数据、reactive（）数据、生命周期钩子函数。<strong>因为是个函数，所以能有返回值</strong></p><p>使用：使用hook函数需要引入，并且需要<strong>创建变量接收函数返回值</strong>。因为组件API都是函数，在hook函数内部<strong>调用了其他方法</strong>，例如调用了onMounted方法就会让在Mounted时i执行内部回调</p><h4 id="toref" tabindex="-1"><a class="header-anchor" href="#toref" aria-hidden="true">#</a> toRef</h4><p>功能：创建一个ref实例对象，value值<strong>指向某个对象的属性</strong></p><p>语法：const name = toRef（person，‘name’）</p><p>对比：</p><ul><li>const name = person.name：name拿到的是person.name的值。如果是个字符串，<strong>name拿到的只是那个字符串</strong></li><li>const name = ref（person，‘name’）：name拿到的是ref实例对象。value指向一个新的对象，只是拿person的‘name’的值来初始化，<strong>它和person的name属性没有联系</strong>，所以name发生改变，是不会影响person对象的name属性的，也就是<strong>没有响应式</strong></li><li>const name = toRef（person，‘name’）：name拿到的是ref实例对象，value指向那个person对象的name属性。也就是说name变化，person.name也会变化，从而导致Proxy的set（）方法调用，重新渲染页面，<strong>有响应式</strong></li></ul><p>toRefs：<strong>直接传入对象person</strong>，不需要传入属性name了。生成一个新的对象，包括的属性有多个RefImpl对象</p><p>用处：有时候需要向外传person，有时候也要传常用属性</p><h3 id="其他composition-api" tabindex="-1"><a class="header-anchor" href="#其他composition-api" aria-hidden="true">#</a> 其他Composition API</h3><h4 id="shallowref" tabindex="-1"><a class="header-anchor" href="#shallowref" aria-hidden="true">#</a> shallowRef</h4><p>功能：浅层次响应式。也就是说<strong>只有RefImpl实例的value</strong>是响应式的</p><ul><li>如果是普通数据，这个数据还是响应式的</li><li>如果是对象，<strong>value不会是Proxy类型，所以对象内部不是响应式</strong>。如果对象内部发生变化，vue是监测不到变化去重新渲染的。只有当整个对象被替换掉，也就是栈内存指向的堆内存地址都发生改变，才会被检测到</li></ul><h4 id="shallowreactive" tabindex="-1"><a class="header-anchor" href="#shallowreactive" aria-hidden="true">#</a> shallowReactive</h4><p>功能：浅层次响应式。只有<strong>对象的直接属性是响应式</strong></p><h4 id="readonly和shallowreadonly" tabindex="-1"><a class="header-anchor" href="#readonly和shallowreadonly" aria-hidden="true">#</a> readonly和shallowReadonly</h4><p>语法：person = readonly（readonly）</p><p>功能：让一个响应式的数据不能被修改</p><p>浅：只让直接属性不能修改，对基本类型没区别</p><p>用处：接收别人传过来的数据，但最好不要改这个数据</p><h4 id="toraw和markraw" tabindex="-1"><a class="header-anchor" href="#toraw和markraw" aria-hidden="true">#</a> toRaw和markRaw</h4><p>toRaw：根据reactive生成的<strong>响应式对象</strong>生成普通对象，let p = toRaw（person）。<strong>ref生成的数据用不了</strong></p><p>markRaw：给普通对象设置，它永远不能变成响应式对象。person.name = markRaw（{aaa：bbb，xxx：yyy}）</p><h4 id="customref自定义ref" tabindex="-1"><a class="header-anchor" href="#customref自定义ref" aria-hidden="true">#</a> customRef自定义ref</h4><p>通过customRef实现重写ref（）</p><p>写的过程：</p><ul><li><strong>声明</strong>函数：function myRef（value）{}</li><li>ref（value）会生成一个RefImpl对象，所以myRef（value）肯定也是返回一个RefImpl对象，这个工作就由customRef（）实现，所以在函数内部<strong>调用customRef（）并且返回customRef（）的返回值</strong>作为结果</li><li><strong>customRef（）的参数是个函数</strong>，就是写要自定义的操作。如果参数不是函数的话，理应是里面有一套自定义的逻辑接收参数，就不是自定义了</li><li>内部函数（）=&gt; { } 的返回值是个对象，<strong>包括getter和setter，实现响应式</strong>。getter在数据被获取时调用，实现把值给页面；setter是修改数据时调用，实现修改页面上的数据 <ul><li>getter：每当value被使用，<strong>getter就要把value给页面</strong>。所以getter的具体操作是return value</li><li>setter：每当value被修改，setter就要修改页面，<strong>用新的值重新渲染页面中用到value的地方</strong>。所以setter的具体操作是：把value改成newValue，用getter<strong>把新的value值给页面</strong>。不是直接在setter中调用getter，而是<strong>通过内部函数（）=&gt; { } 的trigger参数【函数】</strong>，<strong>调用后vue重新解析模板</strong>，这时候模板里用到value的地方需要获取value，就<strong>会让getter再次执行</strong>。还需要在getter中调用track（），让<strong>getter追踪value的变化</strong>，否则getter只在初始化的时候调用把value给页面，后续不管了</li></ul></li></ul><p>代码：</p><pre><code>function myRef(value){
  return customRef((track,trigger)=&gt;{
    return {
      get(){
        console.log(`有地方用到了${value}, 所以getter被调用了，把值给到页面上`)
        track()
        return value
      },
      set(newValue){
        value = newValue
        console.log(`值被修改了，改成了${value}，所以setter被调用了，让vue重新渲染模板，解读模板语法`)
        trigger()
      }
    }
  })
}
</code></pre><h4 id="provide和inject" tabindex="-1"><a class="header-anchor" href="#provide和inject" aria-hidden="true">#</a> provide和inject</h4><p>作用：跨级通信（任意后代），但父子通常用最简单的props</p><p>操作：上级用provide函数提供数据，下级用injecthan数获取数据使用</p><ul><li>上级：provide（‘student’，student【假设定义好了这个对象】）</li><li>下级：let a = inject（‘student’）</li></ul><h4 id="判断是否响应式数据" tabindex="-1"><a class="header-anchor" href="#判断是否响应式数据" aria-hidden="true">#</a> 判断是否响应式数据</h4><ul><li>isRef</li><li>isReactive</li><li>ieReadonly</li><li>isProxy</li></ul><h3 id="composition-api的优势" tabindex="-1"><a class="header-anchor" href="#composition-api的优势" aria-hidden="true">#</a> Composition API的优势</h3><ul><li>复用性强</li><li>结构有序</li></ul><h3 id="新的组件" tabindex="-1"><a class="header-anchor" href="#新的组件" aria-hidden="true">#</a> 新的组件</h3><h4 id="fragment" tabindex="-1"><a class="header-anchor" href="#fragment" aria-hidden="true">#</a> Fragment</h4><p>组件可以没有根标签，所有标签被包含在虚拟的标签Fragment中，解析出来没有Fragment</p><h4 id="teleport" tabindex="-1"><a class="header-anchor" href="#teleport" aria-hidden="true">#</a> Teleport</h4><p>在<strong>组件外部包上teleport标签</strong>，用to属性指定标签，可以用html、body、或者标签选择器，<strong>让包住的内容放到那个容器</strong>而不是当前结构中</p><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h3><h4 id="全局api的转移" tabindex="-1"><a class="header-anchor" href="#全局api的转移" aria-hidden="true">#</a> 全局API的转移</h4><p>Vue3没有引入Vue，不能再通过Vue设置component、mixin、use等，基本都给到了app。</p><p><strong>Vue.prototype要设置的东西，需要到app.config.globalProperties上添加，例如全局事件总线</strong></p><h4 id="其他-1" tabindex="-1"><a class="header-anchor" href="#其他-1" aria-hidden="true">#</a> 其他</h4><ul><li>没了过滤器</li><li>移除了native修饰符，原生和不原生的事件不再有这个决定，而是取决于子组件中是否有用emits配置项接收事件</li><li>不能用keyCode绑定键盘事件</li><li>data必须要是函数</li></ul></div><!--[--><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/vue/nuxt.html" class="" aria-label="nuxt"><!--[--><!--]--><!----><span>nuxt</span><!--[--><!--]--></a></span></p></nav><!--[--><!--]--><!----></main><!--]--></div><div class="search-page" role="search"><span class="search-close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="28" height="28" fill="currentColor"><path d="M224 416c-8.188 0-16.38-3.125-22.62-9.375l-192-192c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L224 338.8l169.4-169.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-192 192C240.4 412.9 232.2 416 224 416z"></path></svg></span><div class="gungnir-search-box"><input placeholder="$ grep ..." autocomplete="off" spellcheck="false" value><!----></div></div><div class="menu-btn-container"><div class="menu-btn-wrapper"><div class="menu-btn"><div style="" class="menu-btn-icon"><span></span><span></span><span></span></div><div style="display:none;" class="menu-text">0</div><svg class="menu-progress"><circle class="menu-border" cx="50%" cy="50%" r="48%" style="stroke-dasharray:0% 314.15926%;"></circle></svg></div><div class="menu-btn-child-wrapper"><div title="toggle color mode" class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"/></svg><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 00283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"/></svg><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.66-53.33L160 80l-53.34-26.67L80 0 53.34 53.33 0 80l53.34 26.67L80 160zm352 128l-26.66 53.33L352 368l53.34 26.67L432 448l26.66-53.33L512 368l-53.34-26.67L432 288zm70.62-193.77L417.77 9.38C411.53 3.12 403.34 0 395.15 0c-8.19 0-16.38 3.12-22.63 9.38L9.38 372.52c-12.5 12.5-12.5 32.76 0 45.25l84.85 84.85c6.25 6.25 14.44 9.37 22.62 9.37 8.19 0 16.38-3.12 22.63-9.37l363.14-363.15c12.5-12.48 12.5-32.75 0-45.24zM359.45 203.46l-50.91-50.91 86.6-86.6 50.91 50.91-86.6 86.6z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z"/></svg></div><!----><div class="toggle-sidebar-button menu-btn-child menu-btn-sidebar" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-1.6 -1.6 19.2 19.2" fill="currentColor"><path d="M14 2a1 1 0 011 1v10a1 1 0 01-1 1H2a1 1 0 01-1-1V3a1 1 0 011-1h12zM2 1a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V3a2 2 0 00-2-2H2z"/><path d="M3 4a1 1 0 011-1h2a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4z"/></svg></div></div></div></div><!----></div><!--]--></div>
    <script type="module" src="/assets/app.4afcc58d.js" defer></script>
  </body>
</html>
